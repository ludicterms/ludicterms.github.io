{"version":3,"sources":["../node_modules/github-slugger/index.js","../node_modules/github-slugger/regex.js","../node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js","../node_modules/micromark-extension-gfm-footnote/lib/syntax.js","../node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js","../node_modules/micromark-extension-gfm-strikethrough/lib/html.js","../node_modules/micromark-extension-gfm-table/lib/syntax.js","../node_modules/micromark-extension-gfm-tagfilter/index.js","../node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js","../node_modules/micromark-extension-gfm/index.js","../node_modules/ccount/index.js","../node_modules/mdast-util-find-and-replace/node_modules/unist-util-visit-parents/index.js","../node_modules/mdast-util-find-and-replace/index.js","../node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js","../node_modules/mdast-util-gfm-autolink-literal/index.js","../node_modules/mdast-util-to-markdown/lib/util/association.js","../node_modules/mdast-util-to-markdown/lib/util/track.js","../node_modules/mdast-util-to-markdown/lib/util/container-flow.js","../node_modules/mdast-util-to-markdown/lib/util/indent-lines.js","../node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js","../node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js","../node_modules/mdast-util-to-markdown/lib/util/safe.js","../node_modules/mdast-util-gfm-footnote/index.js","../node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js","../node_modules/mdast-util-gfm-strikethrough/index.js","../node_modules/mdast-util-to-markdown/lib/handle/inline-code.js","../node_modules/markdown-table/index.js","../node_modules/mdast-util-gfm-table/lib/index.js","../node_modules/mdast-util-to-markdown/lib/handle/list-item.js","../node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js","../node_modules/mdast-util-to-markdown/lib/util/check-bullet.js","../node_modules/mdast-util-gfm-task-list-item/index.js","../node_modules/mdast-util-gfm/lib/index.js","../node_modules/remark-gfm/index.js","../node_modules/hast-util-has-property/index.js","../node_modules/hast-util-to-string/index.js","../node_modules/rehype-slug/index.js","../node_modules/hast-util-heading-rank/index.js"],"names":["regex","require","module","exports","BananaSlug","own","Object","hasOwnProperty","this","reset","slugger","string","maintainCase","toLowerCase","replace","prototype","slug","value","self","originalSlug","call","occurrences","create","www","tokenize","effects","ok","nok","code","consume","w2","w3","dot","after","markdownLineEnding","partial","domain","hasUnderscoreInLastSegment","hasUnderscoreInLastLastSegment","check","namedCharacterReference","done","punctuationContinuation","punctuation","asciiControl","unicodeWhitespace","unicodePunctuation","undefined","path","balance","inPath","continuedPunctuation","parenAtPathEnd","pathEnd","trailingPunctuation","inside","asciiAlpha","wwwAutolink","previousWww","previous","previousUnbalanced","events","enter","attempt","exit","httpAutolink","previousHttp","t1","t2","p","s","colon","slash1","slash2","emailAutolink","hasDot","hasDigitInLastSegment","gfmAtext","previousEmail","atext","label","dotContinuation","dashOrUnderscoreContinuation","asciiAlphanumeric","asciiDigit","afterDashOrUnderscore","text","gfmAutolinkLiteral","markdownLineEndingOrSpace","index","length","result","token","type","_balanced","_gfmAutolinkLiteralWalkedInto","indent","factorySpace","tail","sliceSerialize","gfmFootnote","document","tokenizeDefinitionStart","continuation","tokenizeDefinitionContinuation","gfmFootnoteDefinitionEnd","tokenizeGfmFootnoteCall","add","tokenizePotentialGfmFootnoteCall","resolveTo","resolveToPotentialGfmFootnoteCall","labelStart","defined","parser","gfmFootnotes","id","normalizeIdentifier","start","end","now","charCodeAt","includes","slice","context","assign","marker","column","offset","_bufferIndex","chunk","contentType","replacement","splice","data","size","callStart","callData","callEscape","identifier","_container","atBreak","labelAfter","labelEscape","push","blankLine","gfmStrikethrough","options","single","singleTilde","tokenizer","tokenizeStrikethrough","resolveAll","resolveAllStrikethrough","insideSpan","null","attentionMarkers","_close","open","_open","strikethrough","nextEvents","constructs","more","before","classifyCharacter","Boolean","gfmTable","flow","seenDelimiter","hasDash","align","tableHeaderCount","_align","cellDividerHead","inCellContentHead","cellBreakHead","originalInterrupt","interrupt","tokenizeRowEnd","atDelimiterRowBreak","atRowEndHead","markdownSpace","inWhitespaceHead","inCellContentEscapeHead","rowEndDelimiter","inWhitespaceDelimiter","inFillerDelimiter","afterLeftAlignment","afterRightAlignment","tableClose","nextPrefixedOrBlank","bodyStart","rowStartBody","cellDividerBody","inCellContentBody","cellBreakBody","tableBodyClose","atRowEndBody","inWhitespaceBody","inCellContentEscapeBody","prefixed","lazy","line","disable","_gfmTableDynamicInterruptHack","resolve","inHead","inDelimiterRow","inRow","contentStart","contentEnd","cellStart","seenCellInRow","content","cell","whitespace","reFlow","RegExp","source","tasklistCheck","_gfmTasklistFirstContentOfListItem","close","spaceThenNonSpace","gfmTaskListItem","gfm","combineExtensions","ccount","character","String","TypeError","count","indexOf","visitParents","tree","test","visitor","reverse","is","convert","step","factory","node","parents","name","tagName","defineProperty","visit","subresult","grandparents","Array","isArray","toResult","children","concat","findAndReplace","find","settings","schema","ignored","ignore","pairs","toExpression","toFunction","key","toPairs","pairIndex","grandparent","parent","position","nodes","lastIndex","match","exec","input","global","handler","escape","inConstruct","notInConstruct","gfmAutolinkLiteralFromMarkdown","transforms","findUrl","findEmail","literalAutolink","title","url","literalAutolinkEmail","enterLiteralAutolinkValue","literalAutolinkHttp","literalAutolinkWww","config","autolinkEmail","autolinkProtocol","stack","gfmAutolinkLiteralToMarkdown","unsafe","_","protocol","prefix","parts","split","isCorrectDomain","closingParenIndex","openingParens","closingParens","trail","trailExec","splitUrl","email","association","decodeString","track","options_","lineShift","move","chunks","current","shift","containerFlow","safeOptions","indexStack","tracker","results","child","handle","bulletLastUsed","between","pop","join","left","right","repeat","eol","indentLines","map","one","patternCompile","pattern","_compiled","patternInScope","listInScope","list","none","safe","positions","infos","expression","sort","numerical","escapeBackslashes","charAt","encode","toString","toUpperCase","a","b","whole","gfmFootnoteToMarkdown","footnoteReference","peek","handlers","footnoteDefinition","subexit","blank","containerPhrasing","gfmStrikethroughFromMarkdown","canContainEols","gfmStrikethroughToMarkdown","delete","handleDelete","inlineCode","sequence","serialize","defaultStringLength","toAlignment","codePointAt","gfmTableFromMarkdown","table","d","setData","tableData","enterCell","tableHeader","tableRow","codeText","resume","getData","$0","$1","gfmTableToMarkdown","padding","tableCellPadding","alignDelimiters","tablePipeAlign","stringLength","around","serializeData","handleTableRowAsData","handleTableAsData","tableCell","handleTableCell","matrix","alignments","cellMatrix","sizeMatrix","longestCellByColumn","mostCellsPerRow","rowIndex","row","sizes","columnIndex","Math","max","lines","delimiterStart","delimiterEnd","markdownTable","listItem","listItemIndent","style","Error","checkListItemIndent","bullet","bulletCurrent","checkBullet","ordered","incrementListMarker","spread","ceil","gfmTaskListItemFromMarkdown","taskListCheckValueChecked","exitCheck","taskListCheckValueUnchecked","paragraph","firstParaghraph","siblings","head","checked","sibling","gfmTaskListItemToMarkdown","checkable","checkbox","gfmFromMarkdown","gfmFootnoteDefinition","gfmFootnoteDefinitionLabelString","buffer","gfmFootnoteCall","gfmFootnoteCallString","gfmToMarkdown","extensions","remarkGfm","field","all","slugs","Slugger","rehypeSlug","headingRank","properties","hasProperty"],"mappings":"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","file":"static/js/15.240a6dbd.chunk.js","sourcesContent":["const regex = require('./regex.js')\n\nmodule.exports = BananaSlug\n\nconst own = Object.hasOwnProperty\n\nfunction BananaSlug () {\n  const self = this\n\n  if (!(self instanceof BananaSlug)) return new BananaSlug()\n\n  self.reset()\n}\n\n/**\n * Generate a unique slug.\n * @param  {string} value String of text to slugify\n * @param  {boolean} [false] Keep the current case, otherwise make all lowercase\n * @return {string}       A unique slug string\n */\nBananaSlug.prototype.slug = function (value, maintainCase) {\n  const self = this\n  let slug = slugger(value, maintainCase === true)\n  const originalSlug = slug\n\n  while (own.call(self.occurrences, slug)) {\n    self.occurrences[originalSlug]++\n    slug = originalSlug + '-' + self.occurrences[originalSlug]\n  }\n\n  self.occurrences[slug] = 0\n\n  return slug\n}\n\n/**\n * Reset - Forget all previous slugs\n * @return void\n */\nBananaSlug.prototype.reset = function () {\n  this.occurrences = Object.create(null)\n}\n\nfunction slugger (string, maintainCase) {\n  if (typeof string !== 'string') return ''\n  if (!maintainCase) string = string.toLowerCase()\n  return string.replace(regex, '').replace(/ /g, '-')\n}\n\nBananaSlug.slug = slugger\n","// This module is generated by `script/`.\n/* eslint-disable no-control-regex, no-misleading-character-class, no-useless-escape */\nmodule.exports = /[\\0-\\x1F!-,\\.\\/:-@\\[-\\^`\\{-\\xA9\\xAB-\\xB4\\xB6-\\xB9\\xBB-\\xBF\\xD7\\xF7\\u02C2-\\u02C5\\u02D2-\\u02DF\\u02E5-\\u02EB\\u02ED\\u02EF-\\u02FF\\u0375\\u0378\\u0379\\u037E\\u0380-\\u0385\\u0387\\u038B\\u038D\\u03A2\\u03F6\\u0482\\u0530\\u0557\\u0558\\u055A-\\u055F\\u0589-\\u0590\\u05BE\\u05C0\\u05C3\\u05C6\\u05C8-\\u05CF\\u05EB-\\u05EE\\u05F3-\\u060F\\u061B-\\u061F\\u066A-\\u066D\\u06D4\\u06DD\\u06DE\\u06E9\\u06FD\\u06FE\\u0700-\\u070F\\u074B\\u074C\\u07B2-\\u07BF\\u07F6-\\u07F9\\u07FB\\u07FC\\u07FE\\u07FF\\u082E-\\u083F\\u085C-\\u085F\\u086B-\\u089F\\u08B5\\u08BE-\\u08D2\\u08E2\\u0964\\u0965\\u0970\\u0984\\u098D\\u098E\\u0991\\u0992\\u09A9\\u09B1\\u09B3-\\u09B5\\u09BA\\u09BB\\u09C5\\u09C6\\u09C9\\u09CA\\u09CF-\\u09D6\\u09D8-\\u09DB\\u09DE\\u09E4\\u09E5\\u09F2-\\u09FB\\u09FD\\u09FF\\u0A00\\u0A04\\u0A0B-\\u0A0E\\u0A11\\u0A12\\u0A29\\u0A31\\u0A34\\u0A37\\u0A3A\\u0A3B\\u0A3D\\u0A43-\\u0A46\\u0A49\\u0A4A\\u0A4E-\\u0A50\\u0A52-\\u0A58\\u0A5D\\u0A5F-\\u0A65\\u0A76-\\u0A80\\u0A84\\u0A8E\\u0A92\\u0AA9\\u0AB1\\u0AB4\\u0ABA\\u0ABB\\u0AC6\\u0ACA\\u0ACE\\u0ACF\\u0AD1-\\u0ADF\\u0AE4\\u0AE5\\u0AF0-\\u0AF8\\u0B00\\u0B04\\u0B0D\\u0B0E\\u0B11\\u0B12\\u0B29\\u0B31\\u0B34\\u0B3A\\u0B3B\\u0B45\\u0B46\\u0B49\\u0B4A\\u0B4E-\\u0B55\\u0B58-\\u0B5B\\u0B5E\\u0B64\\u0B65\\u0B70\\u0B72-\\u0B81\\u0B84\\u0B8B-\\u0B8D\\u0B91\\u0B96-\\u0B98\\u0B9B\\u0B9D\\u0BA0-\\u0BA2\\u0BA5-\\u0BA7\\u0BAB-\\u0BAD\\u0BBA-\\u0BBD\\u0BC3-\\u0BC5\\u0BC9\\u0BCE\\u0BCF\\u0BD1-\\u0BD6\\u0BD8-\\u0BE5\\u0BF0-\\u0BFF\\u0C0D\\u0C11\\u0C29\\u0C3A-\\u0C3C\\u0C45\\u0C49\\u0C4E-\\u0C54\\u0C57\\u0C5B-\\u0C5F\\u0C64\\u0C65\\u0C70-\\u0C7F\\u0C84\\u0C8D\\u0C91\\u0CA9\\u0CB4\\u0CBA\\u0CBB\\u0CC5\\u0CC9\\u0CCE-\\u0CD4\\u0CD7-\\u0CDD\\u0CDF\\u0CE4\\u0CE5\\u0CF0\\u0CF3-\\u0CFF\\u0D04\\u0D0D\\u0D11\\u0D45\\u0D49\\u0D4F-\\u0D53\\u0D58-\\u0D5E\\u0D64\\u0D65\\u0D70-\\u0D79\\u0D80\\u0D81\\u0D84\\u0D97-\\u0D99\\u0DB2\\u0DBC\\u0DBE\\u0DBF\\u0DC7-\\u0DC9\\u0DCB-\\u0DCE\\u0DD5\\u0DD7\\u0DE0-\\u0DE5\\u0DF0\\u0DF1\\u0DF4-\\u0E00\\u0E3B-\\u0E3F\\u0E4F\\u0E5A-\\u0E80\\u0E83\\u0E85\\u0E8B\\u0EA4\\u0EA6\\u0EBE\\u0EBF\\u0EC5\\u0EC7\\u0ECE\\u0ECF\\u0EDA\\u0EDB\\u0EE0-\\u0EFF\\u0F01-\\u0F17\\u0F1A-\\u0F1F\\u0F2A-\\u0F34\\u0F36\\u0F38\\u0F3A-\\u0F3D\\u0F48\\u0F6D-\\u0F70\\u0F85\\u0F98\\u0FBD-\\u0FC5\\u0FC7-\\u0FFF\\u104A-\\u104F\\u109E\\u109F\\u10C6\\u10C8-\\u10CC\\u10CE\\u10CF\\u10FB\\u1249\\u124E\\u124F\\u1257\\u1259\\u125E\\u125F\\u1289\\u128E\\u128F\\u12B1\\u12B6\\u12B7\\u12BF\\u12C1\\u12C6\\u12C7\\u12D7\\u1311\\u1316\\u1317\\u135B\\u135C\\u1360-\\u137F\\u1390-\\u139F\\u13F6\\u13F7\\u13FE-\\u1400\\u166D\\u166E\\u1680\\u169B-\\u169F\\u16EB-\\u16ED\\u16F9-\\u16FF\\u170D\\u1715-\\u171F\\u1735-\\u173F\\u1754-\\u175F\\u176D\\u1771\\u1774-\\u177F\\u17D4-\\u17D6\\u17D8-\\u17DB\\u17DE\\u17DF\\u17EA-\\u180A\\u180E\\u180F\\u181A-\\u181F\\u1879-\\u187F\\u18AB-\\u18AF\\u18F6-\\u18FF\\u191F\\u192C-\\u192F\\u193C-\\u1945\\u196E\\u196F\\u1975-\\u197F\\u19AC-\\u19AF\\u19CA-\\u19CF\\u19DA-\\u19FF\\u1A1C-\\u1A1F\\u1A5F\\u1A7D\\u1A7E\\u1A8A-\\u1A8F\\u1A9A-\\u1AA6\\u1AA8-\\u1AAF\\u1ABF-\\u1AFF\\u1B4C-\\u1B4F\\u1B5A-\\u1B6A\\u1B74-\\u1B7F\\u1BF4-\\u1BFF\\u1C38-\\u1C3F\\u1C4A-\\u1C4C\\u1C7E\\u1C7F\\u1C89-\\u1C8F\\u1CBB\\u1CBC\\u1CC0-\\u1CCF\\u1CD3\\u1CFB-\\u1CFF\\u1DFA\\u1F16\\u1F17\\u1F1E\\u1F1F\\u1F46\\u1F47\\u1F4E\\u1F4F\\u1F58\\u1F5A\\u1F5C\\u1F5E\\u1F7E\\u1F7F\\u1FB5\\u1FBD\\u1FBF-\\u1FC1\\u1FC5\\u1FCD-\\u1FCF\\u1FD4\\u1FD5\\u1FDC-\\u1FDF\\u1FED-\\u1FF1\\u1FF5\\u1FFD-\\u203E\\u2041-\\u2053\\u2055-\\u2070\\u2072-\\u207E\\u2080-\\u208F\\u209D-\\u20CF\\u20F1-\\u2101\\u2103-\\u2106\\u2108\\u2109\\u2114\\u2116-\\u2118\\u211E-\\u2123\\u2125\\u2127\\u2129\\u212E\\u213A\\u213B\\u2140-\\u2144\\u214A-\\u214D\\u214F-\\u215F\\u2189-\\u24B5\\u24EA-\\u2BFF\\u2C2F\\u2C5F\\u2CE5-\\u2CEA\\u2CF4-\\u2CFF\\u2D26\\u2D28-\\u2D2C\\u2D2E\\u2D2F\\u2D68-\\u2D6E\\u2D70-\\u2D7E\\u2D97-\\u2D9F\\u2DA7\\u2DAF\\u2DB7\\u2DBF\\u2DC7\\u2DCF\\u2DD7\\u2DDF\\u2E00-\\u2E2E\\u2E30-\\u3004\\u3008-\\u3020\\u3030\\u3036\\u3037\\u303D-\\u3040\\u3097\\u3098\\u309B\\u309C\\u30A0\\u30FB\\u3100-\\u3104\\u3130\\u318F-\\u319F\\u31BB-\\u31EF\\u3200-\\u33FF\\u4DB6-\\u4DFF\\u9FF0-\\u9FFF\\uA48D-\\uA4CF\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA62C-\\uA63F\\uA673\\uA67E\\uA6F2-\\uA716\\uA720\\uA721\\uA789\\uA78A\\uA7C0\\uA7C1\\uA7C7-\\uA7F6\\uA828-\\uA83F\\uA874-\\uA87F\\uA8C6-\\uA8CF\\uA8DA-\\uA8DF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA954-\\uA95F\\uA97D-\\uA97F\\uA9C1-\\uA9CE\\uA9DA-\\uA9DF\\uA9FF\\uAA37-\\uAA3F\\uAA4E\\uAA4F\\uAA5A-\\uAA5F\\uAA77-\\uAA79\\uAAC3-\\uAADA\\uAADE\\uAADF\\uAAF0\\uAAF1\\uAAF7-\\uAB00\\uAB07\\uAB08\\uAB0F\\uAB10\\uAB17-\\uAB1F\\uAB27\\uAB2F\\uAB5B\\uAB68-\\uAB6F\\uABEB\\uABEE\\uABEF\\uABFA-\\uABFF\\uD7A4-\\uD7AF\\uD7C7-\\uD7CA\\uD7FC-\\uD7FF\\uE000-\\uF8FF\\uFA6E\\uFA6F\\uFADA-\\uFAFF\\uFB07-\\uFB12\\uFB18-\\uFB1C\\uFB29\\uFB37\\uFB3D\\uFB3F\\uFB42\\uFB45\\uFBB2-\\uFBD2\\uFD3E-\\uFD4F\\uFD90\\uFD91\\uFDC8-\\uFDEF\\uFDFC-\\uFDFF\\uFE10-\\uFE1F\\uFE30-\\uFE32\\uFE35-\\uFE4C\\uFE50-\\uFE6F\\uFE75\\uFEFD-\\uFF0F\\uFF1A-\\uFF20\\uFF3B-\\uFF3E\\uFF40\\uFF5B-\\uFF65\\uFFBF-\\uFFC1\\uFFC8\\uFFC9\\uFFD0\\uFFD1\\uFFD8\\uFFD9\\uFFDD-\\uFFFF]|\\uD800[\\uDC0C\\uDC27\\uDC3B\\uDC3E\\uDC4E\\uDC4F\\uDC5E-\\uDC7F\\uDCFB-\\uDD3F\\uDD75-\\uDDFC\\uDDFE-\\uDE7F\\uDE9D-\\uDE9F\\uDED1-\\uDEDF\\uDEE1-\\uDEFF\\uDF20-\\uDF2C\\uDF4B-\\uDF4F\\uDF7B-\\uDF7F\\uDF9E\\uDF9F\\uDFC4-\\uDFC7\\uDFD0\\uDFD6-\\uDFFF]|\\uD801[\\uDC9E\\uDC9F\\uDCAA-\\uDCAF\\uDCD4-\\uDCD7\\uDCFC-\\uDCFF\\uDD28-\\uDD2F\\uDD64-\\uDDFF\\uDF37-\\uDF3F\\uDF56-\\uDF5F\\uDF68-\\uDFFF]|\\uD802[\\uDC06\\uDC07\\uDC09\\uDC36\\uDC39-\\uDC3B\\uDC3D\\uDC3E\\uDC56-\\uDC5F\\uDC77-\\uDC7F\\uDC9F-\\uDCDF\\uDCF3\\uDCF6-\\uDCFF\\uDD16-\\uDD1F\\uDD3A-\\uDD7F\\uDDB8-\\uDDBD\\uDDC0-\\uDDFF\\uDE04\\uDE07-\\uDE0B\\uDE14\\uDE18\\uDE36\\uDE37\\uDE3B-\\uDE3E\\uDE40-\\uDE5F\\uDE7D-\\uDE7F\\uDE9D-\\uDEBF\\uDEC8\\uDEE7-\\uDEFF\\uDF36-\\uDF3F\\uDF56-\\uDF5F\\uDF73-\\uDF7F\\uDF92-\\uDFFF]|\\uD803[\\uDC49-\\uDC7F\\uDCB3-\\uDCBF\\uDCF3-\\uDCFF\\uDD28-\\uDD2F\\uDD3A-\\uDEFF\\uDF1D-\\uDF26\\uDF28-\\uDF2F\\uDF51-\\uDFDF\\uDFF7-\\uDFFF]|\\uD804[\\uDC47-\\uDC65\\uDC70-\\uDC7E\\uDCBB-\\uDCCF\\uDCE9-\\uDCEF\\uDCFA-\\uDCFF\\uDD35\\uDD40-\\uDD43\\uDD47-\\uDD4F\\uDD74\\uDD75\\uDD77-\\uDD7F\\uDDC5-\\uDDC8\\uDDCD-\\uDDCF\\uDDDB\\uDDDD-\\uDDFF\\uDE12\\uDE38-\\uDE3D\\uDE3F-\\uDE7F\\uDE87\\uDE89\\uDE8E\\uDE9E\\uDEA9-\\uDEAF\\uDEEB-\\uDEEF\\uDEFA-\\uDEFF\\uDF04\\uDF0D\\uDF0E\\uDF11\\uDF12\\uDF29\\uDF31\\uDF34\\uDF3A\\uDF45\\uDF46\\uDF49\\uDF4A\\uDF4E\\uDF4F\\uDF51-\\uDF56\\uDF58-\\uDF5C\\uDF64\\uDF65\\uDF6D-\\uDF6F\\uDF75-\\uDFFF]|\\uD805[\\uDC4B-\\uDC4F\\uDC5A-\\uDC5D\\uDC60-\\uDC7F\\uDCC6\\uDCC8-\\uDCCF\\uDCDA-\\uDD7F\\uDDB6\\uDDB7\\uDDC1-\\uDDD7\\uDDDE-\\uDDFF\\uDE41-\\uDE43\\uDE45-\\uDE4F\\uDE5A-\\uDE7F\\uDEB9-\\uDEBF\\uDECA-\\uDEFF\\uDF1B\\uDF1C\\uDF2C-\\uDF2F\\uDF3A-\\uDFFF]|\\uD806[\\uDC3B-\\uDC9F\\uDCEA-\\uDCFE\\uDD00-\\uDD9F\\uDDA8\\uDDA9\\uDDD8\\uDDD9\\uDDE2\\uDDE5-\\uDDFF\\uDE3F-\\uDE46\\uDE48-\\uDE4F\\uDE9A-\\uDE9C\\uDE9E-\\uDEBF\\uDEF9-\\uDFFF]|\\uD807[\\uDC09\\uDC37\\uDC41-\\uDC4F\\uDC5A-\\uDC71\\uDC90\\uDC91\\uDCA8\\uDCB7-\\uDCFF\\uDD07\\uDD0A\\uDD37-\\uDD39\\uDD3B\\uDD3E\\uDD48-\\uDD4F\\uDD5A-\\uDD5F\\uDD66\\uDD69\\uDD8F\\uDD92\\uDD99-\\uDD9F\\uDDAA-\\uDEDF\\uDEF7-\\uDFFF]|\\uD808[\\uDF9A-\\uDFFF]|\\uD809[\\uDC6F-\\uDC7F\\uDD44-\\uDFFF]|[\\uD80A\\uD80B\\uD80E-\\uD810\\uD812-\\uD819\\uD823-\\uD82B\\uD82D\\uD82E\\uD830-\\uD833\\uD837\\uD839\\uD83D-\\uD83F\\uD87B-\\uD87D\\uD87F-\\uDB3F\\uDB41-\\uDBFF][\\uDC00-\\uDFFF]|\\uD80D[\\uDC2F-\\uDFFF]|\\uD811[\\uDE47-\\uDFFF]|\\uD81A[\\uDE39-\\uDE3F\\uDE5F\\uDE6A-\\uDECF\\uDEEE\\uDEEF\\uDEF5-\\uDEFF\\uDF37-\\uDF3F\\uDF44-\\uDF4F\\uDF5A-\\uDF62\\uDF78-\\uDF7C\\uDF90-\\uDFFF]|\\uD81B[\\uDC00-\\uDE3F\\uDE80-\\uDEFF\\uDF4B-\\uDF4E\\uDF88-\\uDF8E\\uDFA0-\\uDFDF\\uDFE2\\uDFE4-\\uDFFF]|\\uD821[\\uDFF8-\\uDFFF]|\\uD822[\\uDEF3-\\uDFFF]|\\uD82C[\\uDD1F-\\uDD4F\\uDD53-\\uDD63\\uDD68-\\uDD6F\\uDEFC-\\uDFFF]|\\uD82F[\\uDC6B-\\uDC6F\\uDC7D-\\uDC7F\\uDC89-\\uDC8F\\uDC9A-\\uDC9C\\uDC9F-\\uDFFF]|\\uD834[\\uDC00-\\uDD64\\uDD6A-\\uDD6C\\uDD73-\\uDD7A\\uDD83\\uDD84\\uDD8C-\\uDDA9\\uDDAE-\\uDE41\\uDE45-\\uDFFF]|\\uD835[\\uDC55\\uDC9D\\uDCA0\\uDCA1\\uDCA3\\uDCA4\\uDCA7\\uDCA8\\uDCAD\\uDCBA\\uDCBC\\uDCC4\\uDD06\\uDD0B\\uDD0C\\uDD15\\uDD1D\\uDD3A\\uDD3F\\uDD45\\uDD47-\\uDD49\\uDD51\\uDEA6\\uDEA7\\uDEC1\\uDEDB\\uDEFB\\uDF15\\uDF35\\uDF4F\\uDF6F\\uDF89\\uDFA9\\uDFC3\\uDFCC\\uDFCD]|\\uD836[\\uDC00-\\uDDFF\\uDE37-\\uDE3A\\uDE6D-\\uDE74\\uDE76-\\uDE83\\uDE85-\\uDE9A\\uDEA0\\uDEB0-\\uDFFF]|\\uD838[\\uDC07\\uDC19\\uDC1A\\uDC22\\uDC25\\uDC2B-\\uDCFF\\uDD2D-\\uDD2F\\uDD3E\\uDD3F\\uDD4A-\\uDD4D\\uDD4F-\\uDEBF\\uDEFA-\\uDFFF]|\\uD83A[\\uDCC5-\\uDCCF\\uDCD7-\\uDCFF\\uDD4C-\\uDD4F\\uDD5A-\\uDFFF]|\\uD83B[\\uDC00-\\uDDFF\\uDE04\\uDE20\\uDE23\\uDE25\\uDE26\\uDE28\\uDE33\\uDE38\\uDE3A\\uDE3C-\\uDE41\\uDE43-\\uDE46\\uDE48\\uDE4A\\uDE4C\\uDE50\\uDE53\\uDE55\\uDE56\\uDE58\\uDE5A\\uDE5C\\uDE5E\\uDE60\\uDE63\\uDE65\\uDE66\\uDE6B\\uDE73\\uDE78\\uDE7D\\uDE7F\\uDE8A\\uDE9C-\\uDEA0\\uDEA4\\uDEAA\\uDEBC-\\uDFFF]|\\uD83C[\\uDC00-\\uDD2F\\uDD4A-\\uDD4F\\uDD6A-\\uDD6F\\uDD8A-\\uDFFF]|\\uD869[\\uDED7-\\uDEFF]|\\uD86D[\\uDF35-\\uDF3F]|\\uD86E[\\uDC1E\\uDC1F]|\\uD873[\\uDEA2-\\uDEAF]|\\uD87A[\\uDFE1-\\uDFFF]|\\uD87E[\\uDE1E-\\uDFFF]|\\uDB40[\\uDC00-\\uDCFF\\uDDF0-\\uDFFF]/g\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  asciiControl,\n  asciiDigit,\n  markdownLineEndingOrSpace,\n  markdownLineEnding,\n  unicodePunctuation,\n  unicodeWhitespace\n} from 'micromark-util-character'\nconst www = {\n  tokenize: tokenizeWww,\n  partial: true\n}\nconst domain = {\n  tokenize: tokenizeDomain,\n  partial: true\n}\nconst path = {\n  tokenize: tokenizePath,\n  partial: true\n}\nconst punctuation = {\n  tokenize: tokenizePunctuation,\n  partial: true\n}\nconst namedCharacterReference = {\n  tokenize: tokenizeNamedCharacterReference,\n  partial: true\n}\nconst wwwAutolink = {\n  tokenize: tokenizeWwwAutolink,\n  previous: previousWww\n}\nconst httpAutolink = {\n  tokenize: tokenizeHttpAutolink,\n  previous: previousHttp\n}\nconst emailAutolink = {\n  tokenize: tokenizeEmailAutolink,\n  previous: previousEmail\n}\n/** @type {ConstructRecord} */\n\nconst text = {}\n/** @type {Extension} */\n\nexport const gfmAutolinkLiteral = {\n  text\n}\nlet code = 48 // Add alphanumerics.\n\nwhile (code < 123) {\n  text[code] = emailAutolink\n  code++\n  if (code === 58) code = 65\n  else if (code === 91) code = 97\n}\n\ntext[43] = emailAutolink\ntext[45] = emailAutolink\ntext[46] = emailAutolink\ntext[95] = emailAutolink\ntext[72] = [emailAutolink, httpAutolink]\ntext[104] = [emailAutolink, httpAutolink]\ntext[87] = [emailAutolink, wwwAutolink]\ntext[119] = [emailAutolink, wwwAutolink]\n/** @type {Tokenizer} */\n\nfunction tokenizeEmailAutolink(effects, ok, nok) {\n  const self = this\n  /** @type {boolean} */\n\n  let hasDot\n  /** @type {boolean|undefined} */\n\n  let hasDigitInLastSegment\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (\n      !gfmAtext(code) ||\n      !previousEmail(self.previous) ||\n      previousUnbalanced(self.events)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkEmail')\n    return atext(code)\n  }\n  /** @type {State} */\n\n  function atext(code) {\n    if (gfmAtext(code)) {\n      effects.consume(code)\n      return atext\n    }\n\n    if (code === 64) {\n      effects.consume(code)\n      return label\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function label(code) {\n    if (code === 46) {\n      return effects.check(punctuation, done, dotContinuation)(code)\n    }\n\n    if (code === 45 || code === 95) {\n      return effects.check(punctuation, nok, dashOrUnderscoreContinuation)(code)\n    }\n\n    if (asciiAlphanumeric(code)) {\n      if (!hasDigitInLastSegment && asciiDigit(code)) {\n        hasDigitInLastSegment = true\n      }\n\n      effects.consume(code)\n      return label\n    }\n\n    return done(code)\n  }\n  /** @type {State} */\n\n  function dotContinuation(code) {\n    effects.consume(code)\n    hasDot = true\n    hasDigitInLastSegment = undefined\n    return label\n  }\n  /** @type {State} */\n\n  function dashOrUnderscoreContinuation(code) {\n    effects.consume(code)\n    return afterDashOrUnderscore\n  }\n  /** @type {State} */\n\n  function afterDashOrUnderscore(code) {\n    if (code === 46) {\n      return effects.check(punctuation, nok, dotContinuation)(code)\n    }\n\n    return label(code)\n  }\n  /** @type {State} */\n\n  function done(code) {\n    if (hasDot && !hasDigitInLastSegment) {\n      effects.exit('literalAutolinkEmail')\n      effects.exit('literalAutolink')\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeWwwAutolink(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (\n      (code !== 87 && code !== 119) ||\n      !previousWww(self.previous) ||\n      previousUnbalanced(self.events)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkWww') // For `www.` we check instead of attempt, because when it matches, GH\n    // treats it as part of a domain (yes, it says a valid domain must come\n    // after `www.`, but thats not how its implemented by them).\n\n    return effects.check(\n      www,\n      effects.attempt(domain, effects.attempt(path, done), nok),\n      nok\n    )(code)\n  }\n  /** @type {State} */\n\n  function done(code) {\n    effects.exit('literalAutolinkWww')\n    effects.exit('literalAutolink')\n    return ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeHttpAutolink(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (\n      (code !== 72 && code !== 104) ||\n      !previousHttp(self.previous) ||\n      previousUnbalanced(self.events)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkHttp')\n    effects.consume(code)\n    return t1\n  }\n  /** @type {State} */\n\n  function t1(code) {\n    if (code === 84 || code === 116) {\n      effects.consume(code)\n      return t2\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function t2(code) {\n    if (code === 84 || code === 116) {\n      effects.consume(code)\n      return p\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function p(code) {\n    if (code === 80 || code === 112) {\n      effects.consume(code)\n      return s\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function s(code) {\n    if (code === 83 || code === 115) {\n      effects.consume(code)\n      return colon\n    }\n\n    return colon(code)\n  }\n  /** @type {State} */\n\n  function colon(code) {\n    if (code === 58) {\n      effects.consume(code)\n      return slash1\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function slash1(code) {\n    if (code === 47) {\n      effects.consume(code)\n      return slash2\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function slash2(code) {\n    if (code === 47) {\n      effects.consume(code)\n      return after\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    return code === null ||\n      asciiControl(code) ||\n      unicodeWhitespace(code) ||\n      unicodePunctuation(code)\n      ? nok(code)\n      : effects.attempt(domain, effects.attempt(path, done), nok)(code)\n  }\n  /** @type {State} */\n\n  function done(code) {\n    effects.exit('literalAutolinkHttp')\n    effects.exit('literalAutolink')\n    return ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeWww(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.consume(code)\n    return w2\n  }\n  /** @type {State} */\n\n  function w2(code) {\n    if (code === 87 || code === 119) {\n      effects.consume(code)\n      return w3\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function w3(code) {\n    if (code === 87 || code === 119) {\n      effects.consume(code)\n      return dot\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function dot(code) {\n    if (code === 46) {\n      effects.consume(code)\n      return after\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    return code === null || markdownLineEnding(code) ? nok(code) : ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeDomain(effects, ok, nok) {\n  /** @type {boolean|undefined} */\n  let hasUnderscoreInLastSegment\n  /** @type {boolean|undefined} */\n\n  let hasUnderscoreInLastLastSegment\n  return domain\n  /** @type {State} */\n\n  function domain(code) {\n    if (code === 38) {\n      return effects.check(\n        namedCharacterReference,\n        done,\n        punctuationContinuation\n      )(code)\n    }\n\n    if (code === 46 || code === 95) {\n      return effects.check(punctuation, done, punctuationContinuation)(code)\n    } // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can\n    // occur, which sounds like ASCII only, but they also support `www..com`,\n    // so thats Unicode.\n    // Instead of some new production for Unicode alphanumerics, markdown\n    // already has that for Unicode punctuation and whitespace, so use those.\n\n    if (\n      code === null ||\n      asciiControl(code) ||\n      unicodeWhitespace(code) ||\n      (code !== 45 && unicodePunctuation(code))\n    ) {\n      return done(code)\n    }\n\n    effects.consume(code)\n    return domain\n  }\n  /** @type {State} */\n\n  function punctuationContinuation(code) {\n    if (code === 46) {\n      hasUnderscoreInLastLastSegment = hasUnderscoreInLastSegment\n      hasUnderscoreInLastSegment = undefined\n      effects.consume(code)\n      return domain\n    }\n\n    if (code === 95) hasUnderscoreInLastSegment = true\n    effects.consume(code)\n    return domain\n  }\n  /** @type {State} */\n\n  function done(code) {\n    if (!hasUnderscoreInLastLastSegment && !hasUnderscoreInLastSegment) {\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizePath(effects, ok) {\n  let balance = 0\n  return inPath\n  /** @type {State} */\n\n  function inPath(code) {\n    if (code === 38) {\n      return effects.check(\n        namedCharacterReference,\n        ok,\n        continuedPunctuation\n      )(code)\n    }\n\n    if (code === 40) {\n      balance++\n    }\n\n    if (code === 41) {\n      return effects.check(\n        punctuation,\n        parenAtPathEnd,\n        continuedPunctuation\n      )(code)\n    }\n\n    if (pathEnd(code)) {\n      return ok(code)\n    }\n\n    if (trailingPunctuation(code)) {\n      return effects.check(punctuation, ok, continuedPunctuation)(code)\n    }\n\n    effects.consume(code)\n    return inPath\n  }\n  /** @type {State} */\n\n  function continuedPunctuation(code) {\n    effects.consume(code)\n    return inPath\n  }\n  /** @type {State} */\n\n  function parenAtPathEnd(code) {\n    balance--\n    return balance < 0 ? ok(code) : continuedPunctuation(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeNamedCharacterReference(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.consume(code)\n    return inside\n  }\n  /** @type {State} */\n\n  function inside(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return inside\n    }\n\n    if (code === 59) {\n      effects.consume(code)\n      return after\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    // If the named character reference is followed by the end of the path, its\n    // not continued punctuation.\n    return pathEnd(code) ? ok(code) : nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizePunctuation(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.consume(code)\n    return after\n  }\n  /** @type {State} */\n\n  function after(code) {\n    // Check the next.\n    if (trailingPunctuation(code)) {\n      effects.consume(code)\n      return after\n    } // If the punctuation marker is followed by the end of the path, its not\n    // continued punctuation.\n\n    return pathEnd(code) ? ok(code) : nok(code)\n  }\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */\n\nfunction trailingPunctuation(code) {\n  return (\n    code === 33 ||\n    code === 34 ||\n    code === 39 ||\n    code === 41 ||\n    code === 42 ||\n    code === 44 ||\n    code === 46 ||\n    code === 58 ||\n    code === 59 ||\n    code === 60 ||\n    code === 63 ||\n    code === 95 ||\n    code === 126\n  )\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */\n\nfunction pathEnd(code) {\n  return code === null || code === 60 || markdownLineEndingOrSpace(code)\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */\n\nfunction gfmAtext(code) {\n  return (\n    code === 43 ||\n    code === 45 ||\n    code === 46 ||\n    code === 95 ||\n    asciiAlphanumeric(code)\n  )\n}\n/** @type {Previous} */\n\nfunction previousWww(code) {\n  return (\n    code === null ||\n    code === 40 ||\n    code === 42 ||\n    code === 95 ||\n    code === 126 ||\n    markdownLineEndingOrSpace(code)\n  )\n}\n/** @type {Previous} */\n\nfunction previousHttp(code) {\n  return code === null || !asciiAlpha(code)\n}\n/** @type {Previous} */\n\nfunction previousEmail(code) {\n  return code !== 47 && previousHttp(code)\n}\n/**\n * @param {Array<Event>} events\n * @returns {boolean}\n */\n\nfunction previousUnbalanced(events) {\n  let index = events.length\n  let result = false\n\n  while (index--) {\n    const token = events[index][1]\n\n    if (\n      (token.type === 'labelLink' || token.type === 'labelImage') &&\n      !token._balanced\n    ) {\n      result = true\n      break\n    } // @ts-expect-error If weve seen this token, and it was marked as not\n    // having any unbalanced bracket before it, we can exit.\n\n    if (token._gfmAutolinkLiteralWalkedInto) {\n      result = false\n      break\n    }\n  }\n\n  if (events.length > 0 && !result) {\n    // @ts-expect-error Mark the last token as walked into w/o finding\n    // anything.\n    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true\n  }\n\n  return result\n}\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Event} Event\n */\nimport {blankLine} from 'micromark-core-commonmark'\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace\n} from 'micromark-util-character'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nconst indent = {\n  tokenize: tokenizeIndent,\n  partial: true\n}\n/**\n * @returns {Extension}\n */\n\nexport function gfmFootnote() {\n  /** @type {Extension} */\n  return {\n    document: {\n      [91]: {\n        tokenize: tokenizeDefinitionStart,\n        continuation: {\n          tokenize: tokenizeDefinitionContinuation\n        },\n        exit: gfmFootnoteDefinitionEnd\n      }\n    },\n    text: {\n      [91]: {\n        tokenize: tokenizeGfmFootnoteCall\n      },\n      [93]: {\n        add: 'after',\n        tokenize: tokenizePotentialGfmFootnoteCall,\n        resolveTo: resolveToPotentialGfmFootnoteCall\n      }\n    }\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizePotentialGfmFootnoteCall(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {Array<string>} */\n  // @ts-expect-error Its fine!\n\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  /** @type {Token} */\n\n  let labelStart // Find an opening.\n\n  while (index--) {\n    const token = self.events[index][1]\n\n    if (token.type === 'labelImage') {\n      labelStart = token\n      break\n    } // Exit if weve walked far enough.\n\n    if (\n      token.type === 'gfmFootnoteCall' ||\n      token.type === 'labelLink' ||\n      token.type === 'label' ||\n      token.type === 'image' ||\n      token.type === 'link'\n    ) {\n      break\n    }\n  }\n\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (!labelStart || !labelStart._balanced) {\n      return nok(code)\n    }\n\n    const id = normalizeIdentifier(\n      self.sliceSerialize({\n        start: labelStart.end,\n        end: self.now()\n      })\n    )\n\n    if (id.charCodeAt(0) !== 94 || !defined.includes(id.slice(1))) {\n      return nok(code)\n    }\n\n    effects.enter('gfmFootnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallLabelMarker')\n    return ok(code)\n  }\n}\n/** @type {Resolver} */\n\nfunction resolveToPotentialGfmFootnoteCall(events, context) {\n  let index = events.length\n  /** @type {Token|undefined} */\n\n  let labelStart // Find an opening.\n\n  while (index--) {\n    if (\n      events[index][1].type === 'labelImage' &&\n      events[index][0] === 'enter'\n    ) {\n      labelStart = events[index][1]\n      break\n    }\n  }\n\n  // Change the `labelImageMarker` to a `data`.\n  events[index + 1][1].type = 'data'\n  events[index + 3][1].type = 'gfmFootnoteCallLabelMarker' // The whole (without `!`):\n\n  const call = {\n    type: 'gfmFootnoteCall',\n    start: Object.assign({}, events[index + 3][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  } // The `^` marker\n\n  const marker = {\n    type: 'gfmFootnoteCallMarker',\n    start: Object.assign({}, events[index + 3][1].end),\n    end: Object.assign({}, events[index + 3][1].end)\n  } // Increment the end 1 character.\n\n  marker.end.column++\n  marker.end.offset++\n  marker.end._bufferIndex++\n  const string = {\n    type: 'gfmFootnoteCallString',\n    start: Object.assign({}, marker.end),\n    end: Object.assign({}, events[events.length - 1][1].start)\n  }\n  const chunk = {\n    type: 'chunkString',\n    contentType: 'string',\n    start: Object.assign({}, string.start),\n    end: Object.assign({}, string.end)\n  }\n  /** @type {Array<Event>} */\n\n  const replacement = [\n    // Take the `labelImageMarker` (now `data`, the `!`)\n    events[index + 1],\n    events[index + 2],\n    ['enter', call, context], // The `[`\n    events[index + 3],\n    events[index + 4], // The `^`.\n    ['enter', marker, context],\n    ['exit', marker, context], // Everything in between.\n    ['enter', string, context],\n    ['enter', chunk, context],\n    ['exit', chunk, context],\n    ['exit', string, context], // The ending (`]`, properly parsed and labelled).\n    events[events.length - 2],\n    events[events.length - 1],\n    ['exit', call, context]\n  ]\n  events.splice(index, events.length - index + 1, ...replacement)\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeGfmFootnoteCall(effects, ok, nok) {\n  const self = this\n  /** @type {Array<string>} */\n  // @ts-expect-error Its fine!\n\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  let size = 0\n  /** @type {boolean} */\n\n  let data\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('gfmFootnoteCall')\n    effects.enter('gfmFootnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallLabelMarker')\n    return callStart\n  }\n  /** @type {State} */\n\n  function callStart(code) {\n    if (code !== 94) return nok(code)\n    effects.enter('gfmFootnoteCallMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallMarker')\n    effects.enter('gfmFootnoteCallString')\n    effects.enter('chunkString').contentType = 'string'\n    return callData\n  }\n  /** @type {State} */\n\n  function callData(code) {\n    /** @type {Token} */\n    let token\n\n    if (code === null || code === 91 || size++ > 999) {\n      return nok(code)\n    }\n\n    if (code === 93) {\n      if (!data) {\n        return nok(code)\n      }\n\n      effects.exit('chunkString')\n      token = effects.exit('gfmFootnoteCallString')\n      return defined.includes(normalizeIdentifier(self.sliceSerialize(token)))\n        ? end(code)\n        : nok(code)\n    }\n\n    effects.consume(code)\n\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true\n    }\n\n    return code === 92 ? callEscape : callData\n  }\n  /** @type {State} */\n\n  function callEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code)\n      size++\n      return callData\n    }\n\n    return callData(code)\n  }\n  /** @type {State} */\n\n  function end(code) {\n    effects.enter('gfmFootnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallLabelMarker')\n    effects.exit('gfmFootnoteCall')\n    return ok\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeDefinitionStart(effects, ok, nok) {\n  const self = this\n  /** @type {Array<string>} */\n  // @ts-expect-error Its fine!\n\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  /** @type {string} */\n\n  let identifier\n  let size = 0\n  /** @type {boolean|undefined} */\n\n  let data\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('gfmFootnoteDefinition')._container = true\n    effects.enter('gfmFootnoteDefinitionLabel')\n    effects.enter('gfmFootnoteDefinitionLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteDefinitionLabelMarker')\n    return labelStart\n  }\n  /** @type {State} */\n\n  function labelStart(code) {\n    if (code === 94) {\n      effects.enter('gfmFootnoteDefinitionMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteDefinitionMarker')\n      effects.enter('gfmFootnoteDefinitionLabelString')\n      return atBreak\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function atBreak(code) {\n    /** @type {Token} */\n    let token\n\n    if (code === null || code === 91 || size > 999) {\n      return nok(code)\n    }\n\n    if (code === 93) {\n      if (!data) {\n        return nok(code)\n      }\n\n      token = effects.exit('gfmFootnoteDefinitionLabelString')\n      identifier = normalizeIdentifier(self.sliceSerialize(token))\n      effects.enter('gfmFootnoteDefinitionLabelMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteDefinitionLabelMarker')\n      effects.exit('gfmFootnoteDefinitionLabel')\n      return labelAfter\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      size++\n      return atBreak\n    }\n\n    effects.enter('chunkString').contentType = 'string'\n    return label(code)\n  }\n  /** @type {State} */\n\n  function label(code) {\n    if (\n      code === null ||\n      markdownLineEnding(code) ||\n      code === 91 ||\n      code === 93 ||\n      size > 999\n    ) {\n      effects.exit('chunkString')\n      return atBreak(code)\n    }\n\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true\n    }\n\n    size++\n    effects.consume(code)\n    return code === 92 ? labelEscape : label\n  }\n  /** @type {State} */\n\n  function labelEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code)\n      size++\n      return label\n    }\n\n    return label(code)\n  }\n  /** @type {State} */\n\n  function labelAfter(code) {\n    if (code === 58) {\n      effects.enter('definitionMarker')\n      effects.consume(code)\n      effects.exit('definitionMarker') // Any whitespace after the marker is eaten, forming indented code\n      // is not possible.\n      // No space is also fine, just like a block quote marker.\n\n      return factorySpace(effects, done, 'gfmFootnoteDefinitionWhitespace')\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function done(code) {\n    if (!defined.includes(identifier)) {\n      defined.push(identifier)\n    }\n\n    return ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeDefinitionContinuation(effects, ok, nok) {\n  // Either a blank line, which is okay, or an indented thing.\n  return effects.check(blankLine, ok, effects.attempt(indent, ok, nok))\n}\n/** @type {Exiter} */\n\nfunction gfmFootnoteDefinitionEnd(effects) {\n  effects.exit('gfmFootnoteDefinition')\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'gfmFootnoteDefinitionIndent',\n    4 + 1\n  )\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'gfmFootnoteDefinitionIndent' &&\n      tail[2].sliceSerialize(tail[1], true).length === 4\n      ? ok(code)\n      : nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Event} Event\n */\n\n/**\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean} [singleTilde=true]\n *   Whether to support strikethrough with a single tilde (`boolean`, default:\n *   `true`).\n *   Single tildes work on github.com, but are technically prohibited by the\n *   GFM spec.\n */\nimport {splice} from 'micromark-util-chunked'\nimport {classifyCharacter} from 'micromark-util-classify-character'\nimport {resolveAll} from 'micromark-util-resolve-all'\n\n/**\n * @param {Options} [options]\n * @returns {Extension}\n */\nexport function gfmStrikethrough(options = {}) {\n  let single = options.singleTilde\n  const tokenizer = {\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  }\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  return {\n    text: {\n      [126]: tokenizer\n    },\n    insideSpan: {\n      null: [tokenizer]\n    },\n    attentionMarkers: {\n      null: [126]\n    }\n  }\n  /**\n   * Take events and resolve strikethrough.\n   *\n   * @type {Resolver}\n   */\n\n  function resolveAllStrikethrough(events, context) {\n    let index = -1 // Walk through all events.\n\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (\n        events[index][0] === 'enter' &&\n        events[index][1].type === 'strikethroughSequenceTemporary' &&\n        events[index][1]._close\n      ) {\n        let open = index // Now walk back to find an opener.\n\n        while (open--) {\n          // Find a token that can open the closer.\n          if (\n            events[open][0] === 'exit' &&\n            events[open][1].type === 'strikethroughSequenceTemporary' &&\n            events[open][1]._open && // If the sizes are the same:\n            events[index][1].end.offset - events[index][1].start.offset ===\n              events[open][1].end.offset - events[open][1].start.offset\n          ) {\n            events[index][1].type = 'strikethroughSequence'\n            events[open][1].type = 'strikethroughSequence'\n            const strikethrough = {\n              type: 'strikethrough',\n              start: Object.assign({}, events[open][1].start),\n              end: Object.assign({}, events[index][1].end)\n            }\n            const text = {\n              type: 'strikethroughText',\n              start: Object.assign({}, events[open][1].end),\n              end: Object.assign({}, events[index][1].start)\n            } // Opening.\n\n            const nextEvents = [\n              ['enter', strikethrough, context],\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context],\n              ['enter', text, context]\n            ] // Between.\n\n            splice(\n              nextEvents,\n              nextEvents.length,\n              0,\n              resolveAll(\n                context.parser.constructs.insideSpan.null,\n                events.slice(open + 1, index),\n                context\n              )\n            ) // Closing.\n\n            splice(nextEvents, nextEvents.length, 0, [\n              ['exit', text, context],\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context],\n              ['exit', strikethrough, context]\n            ])\n            splice(events, open - 1, index - open + 3, nextEvents)\n            index = open + nextEvents.length - 2\n            break\n          }\n        }\n      }\n    }\n\n    index = -1\n\n    while (++index < events.length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = 'data'\n      }\n    }\n\n    return events\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeStrikethrough(effects, ok, nok) {\n    const previous = this.previous\n    const events = this.events\n    let size = 0\n    return start\n    /** @type {State} */\n\n    function start(code) {\n      if (\n        previous === 126 &&\n        events[events.length - 1][1].type !== 'characterEscape'\n      ) {\n        return nok(code)\n      }\n\n      effects.enter('strikethroughSequenceTemporary')\n      return more(code)\n    }\n    /** @type {State} */\n\n    function more(code) {\n      const before = classifyCharacter(previous)\n\n      if (code === 126) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code)\n        effects.consume(code)\n        size++\n        return more\n      }\n\n      if (size < 2 && !single) return nok(code)\n      const token = effects.exit('strikethroughSequenceTemporary')\n      const after = classifyCharacter(code)\n      token._open = !after || (after === 2 && Boolean(before))\n      token._close = !before || (before === 2 && Boolean(after))\n      return ok(code)\n    }\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */\n\n/** @type {HtmlExtension} */\nexport const gfmStrikethroughHtml = {\n  enter: {\n    strikethrough() {\n      this.tag('<del>')\n    }\n  },\n  exit: {\n    strikethrough() {\n      this.tag('</del>')\n    }\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n */\n\n/**\n * @typedef {'left'|'center'|'right'|'none'} Align\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\n\n/** @type {Extension} */\nexport const gfmTable = {\n  flow: {\n    null: {\n      tokenize: tokenizeTable,\n      resolve: resolveTable\n    }\n  }\n}\nconst nextPrefixedOrBlank = {\n  tokenize: tokenizeNextPrefixedOrBlank,\n  partial: true\n}\n/** @type {Resolver} */\n\nfunction resolveTable(events, context) {\n  let index = -1\n  /** @type {boolean|undefined} */\n\n  let inHead\n  /** @type {boolean|undefined} */\n\n  let inDelimiterRow\n  /** @type {boolean|undefined} */\n\n  let inRow\n  /** @type {number|undefined} */\n\n  let contentStart\n  /** @type {number|undefined} */\n\n  let contentEnd\n  /** @type {number|undefined} */\n\n  let cellStart\n  /** @type {boolean|undefined} */\n\n  let seenCellInRow\n\n  while (++index < events.length) {\n    const token = events[index][1]\n\n    if (inRow) {\n      if (token.type === 'temporaryTableCellContent') {\n        contentStart = contentStart || index\n        contentEnd = index\n      }\n\n      if (\n        // Combine separate content parts into one.\n        (token.type === 'tableCellDivider' || token.type === 'tableRow') &&\n        contentEnd\n      ) {\n        const content = {\n          type: 'tableContent',\n          start: events[contentStart][1].start,\n          end: events[contentEnd][1].end\n        }\n        /** @type {Token} */\n\n        const text = {\n          type: 'chunkText',\n          start: content.start,\n          end: content.end,\n          // @ts-expect-error Its fine.\n          contentType: 'text'\n        }\n        events.splice(\n          contentStart,\n          contentEnd - contentStart + 1,\n          ['enter', content, context],\n          ['enter', text, context],\n          ['exit', text, context],\n          ['exit', content, context]\n        )\n        index -= contentEnd - contentStart - 3\n        contentStart = undefined\n        contentEnd = undefined\n      }\n    }\n\n    if (\n      events[index][0] === 'exit' &&\n      cellStart !== undefined &&\n      cellStart + (seenCellInRow ? 0 : 1) < index &&\n      (token.type === 'tableCellDivider' ||\n        (token.type === 'tableRow' &&\n          (cellStart + 3 < index ||\n            events[cellStart][1].type !== 'whitespace')))\n    ) {\n      const cell = {\n        type: inDelimiterRow\n          ? 'tableDelimiter'\n          : inHead\n          ? 'tableHeader'\n          : 'tableData',\n        start: events[cellStart][1].start,\n        end: events[index][1].end\n      }\n      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, [\n        'exit',\n        cell,\n        context\n      ])\n      events.splice(cellStart, 0, ['enter', cell, context])\n      index += 2\n      cellStart = index + 1\n      seenCellInRow = true\n    }\n\n    if (token.type === 'tableRow') {\n      inRow = events[index][0] === 'enter'\n\n      if (inRow) {\n        cellStart = index + 1\n        seenCellInRow = false\n      }\n    }\n\n    if (token.type === 'tableDelimiterRow') {\n      inDelimiterRow = events[index][0] === 'enter'\n\n      if (inDelimiterRow) {\n        cellStart = index + 1\n        seenCellInRow = false\n      }\n    }\n\n    if (token.type === 'tableHead') {\n      inHead = events[index][0] === 'enter'\n    }\n  }\n\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeTable(effects, ok, nok) {\n  const self = this\n  /** @type {Array<Align>} */\n\n  const align = []\n  let tableHeaderCount = 0\n  /** @type {boolean|undefined} */\n\n  let seenDelimiter\n  /** @type {boolean|undefined} */\n\n  let hasDash\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    // @ts-expect-error Custom.\n    effects.enter('table')._align = align\n    effects.enter('tableHead')\n    effects.enter('tableRow') // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerHead(code)\n    }\n\n    tableHeaderCount++\n    effects.enter('temporaryTableCellContent') // Cant be space or eols at the start of a construct, so were in a cell.\n\n    return inCellContentHead(code)\n  }\n  /** @type {State} */\n\n  function cellDividerHead(code) {\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    seenDelimiter = true\n    return cellBreakHead\n  }\n  /** @type {State} */\n\n  function cellBreakHead(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return atRowEndHead(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    if (seenDelimiter) {\n      seenDelimiter = undefined\n      tableHeaderCount++\n    }\n\n    if (code === 124) {\n      return cellDividerHead(code)\n    } // Anything else is cell content.\n\n    effects.enter('temporaryTableCellContent')\n    return inCellContentHead(code)\n  }\n  /** @type {State} */\n\n  function inWhitespaceHead(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    effects.exit('whitespace')\n    return cellBreakHead(code)\n  }\n  /** @type {State} */\n\n  function inCellContentHead(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakHead(code)\n    }\n\n    effects.consume(code)\n    return code === 92 ? inCellContentEscapeHead : inCellContentHead\n  }\n  /** @type {State} */\n\n  function inCellContentEscapeHead(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return inCellContentHead\n    } // Anything else.\n\n    return inCellContentHead(code)\n  }\n  /** @type {State} */\n\n  function atRowEndHead(code) {\n    if (code === null) {\n      return nok(code)\n    }\n\n    effects.exit('tableRow')\n    effects.exit('tableHead')\n    const originalInterrupt = self.interrupt\n    self.interrupt = true\n    return effects.attempt(\n      {\n        tokenize: tokenizeRowEnd,\n        partial: true\n      },\n      function (code) {\n        self.interrupt = originalInterrupt\n        effects.enter('tableDelimiterRow')\n        return atDelimiterRowBreak(code)\n      },\n      function (code) {\n        self.interrupt = originalInterrupt\n        return nok(code)\n      }\n    )(code)\n  }\n  /** @type {State} */\n\n  function atDelimiterRowBreak(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return rowEndDelimiter(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      align.push('none')\n      return inFillerDelimiter\n    }\n\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n      align.push('left')\n      return afterLeftAlignment\n    } // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function inWhitespaceDelimiter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    effects.exit('whitespace')\n    return atDelimiterRowBreak(code)\n  }\n  /** @type {State} */\n\n  function inFillerDelimiter(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return inFillerDelimiter\n    }\n\n    effects.exit('tableDelimiterFiller')\n\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n      align[align.length - 1] =\n        align[align.length - 1] === 'left' ? 'center' : 'right'\n      return afterRightAlignment\n    }\n\n    return atDelimiterRowBreak(code)\n  }\n  /** @type {State} */\n\n  function afterLeftAlignment(code) {\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      return inFillerDelimiter\n    } // Anything else is not ok.\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function afterRightAlignment(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return rowEndDelimiter(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    } // `|`\n\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function rowEndDelimiter(code) {\n    effects.exit('tableDelimiterRow') // Exit if there was no dash at all, or if the header cell count is not the\n    // delimiter cell count.\n\n    if (!hasDash || tableHeaderCount !== align.length) {\n      return nok(code)\n    }\n\n    if (code === null) {\n      return tableClose(code)\n    }\n\n    return effects.check(\n      nextPrefixedOrBlank,\n      tableClose,\n      effects.attempt(\n        {\n          tokenize: tokenizeRowEnd,\n          partial: true\n        },\n        factorySpace(effects, bodyStart, 'linePrefix', 4),\n        tableClose\n      )\n    )(code)\n  }\n  /** @type {State} */\n\n  function tableClose(code) {\n    effects.exit('table')\n    return ok(code)\n  }\n  /** @type {State} */\n\n  function bodyStart(code) {\n    effects.enter('tableBody')\n    return rowStartBody(code)\n  }\n  /** @type {State} */\n\n  function rowStartBody(code) {\n    effects.enter('tableRow') // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerBody(code)\n    }\n\n    effects.enter('temporaryTableCellContent') // Cant be space or eols at the start of a construct, so were in a cell.\n\n    return inCellContentBody(code)\n  }\n  /** @type {State} */\n\n  function cellDividerBody(code) {\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    return cellBreakBody\n  }\n  /** @type {State} */\n\n  function cellBreakBody(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return atRowEndBody(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceBody\n    } // `|`\n\n    if (code === 124) {\n      return cellDividerBody(code)\n    } // Anything else is cell content.\n\n    effects.enter('temporaryTableCellContent')\n    return inCellContentBody(code)\n  }\n  /** @type {State} */\n\n  function inWhitespaceBody(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceBody\n    }\n\n    effects.exit('whitespace')\n    return cellBreakBody(code)\n  }\n  /** @type {State} */\n\n  function inCellContentBody(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakBody(code)\n    }\n\n    effects.consume(code)\n    return code === 92 ? inCellContentEscapeBody : inCellContentBody\n  }\n  /** @type {State} */\n\n  function inCellContentEscapeBody(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return inCellContentBody\n    } // Anything else.\n\n    return inCellContentBody(code)\n  }\n  /** @type {State} */\n\n  function atRowEndBody(code) {\n    effects.exit('tableRow')\n\n    if (code === null) {\n      return tableBodyClose(code)\n    }\n\n    return effects.check(\n      nextPrefixedOrBlank,\n      tableBodyClose,\n      effects.attempt(\n        {\n          tokenize: tokenizeRowEnd,\n          partial: true\n        },\n        factorySpace(effects, rowStartBody, 'linePrefix', 4),\n        tableBodyClose\n      )\n    )(code)\n  }\n  /** @type {State} */\n\n  function tableBodyClose(code) {\n    effects.exit('tableBody')\n    return tableClose(code)\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeRowEnd(effects, ok, nok) {\n    return start\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return factorySpace(effects, prefixed, 'linePrefix')\n    }\n    /** @type {State} */\n\n    function prefixed(code) {\n      // Blank or interrupting line.\n      if (\n        self.parser.lazy[self.now().line] ||\n        code === null ||\n        markdownLineEnding(code)\n      ) {\n        return nok(code)\n      }\n\n      const tail = self.events[self.events.length - 1] // Indented code can interrupt delimiter and body rows.\n\n      if (\n        !self.parser.constructs.disable.null.includes('codeIndented') &&\n        tail &&\n        tail[1].type === 'linePrefix' &&\n        tail[2].sliceSerialize(tail[1], true).length >= 4\n      ) {\n        return nok(code)\n      }\n\n      self._gfmTableDynamicInterruptHack = true\n      return effects.check(\n        self.parser.constructs.flow,\n        function (code) {\n          self._gfmTableDynamicInterruptHack = false\n          return nok(code)\n        },\n        function (code) {\n          self._gfmTableDynamicInterruptHack = false\n          return ok(code)\n        }\n      )(code)\n    }\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeNextPrefixedOrBlank(effects, ok, nok) {\n  let size = 0\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    // This is a check, so we dont care about tokens, but we open a bogus one\n    // so were valid.\n    effects.enter('check') // EOL.\n\n    effects.consume(code)\n    return whitespace\n  }\n  /** @type {State} */\n\n  function whitespace(code) {\n    if (code === -1 || code === 32) {\n      effects.consume(code)\n      size++\n      return size === 4 ? ok : whitespace\n    } // EOF or whitespace\n\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      return ok(code)\n    } // Anything else.\n\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').CompileContext} CompileContext\n */\n\n/**\n * An opening or closing tag, followed by a case-insensitive specific tag name,\n * followed by HTML whitespace, a greater than, or a slash.\n */\nconst reFlow =\n  /<(\\/?)(iframe|noembed|noframes|plaintext|script|style|title|textarea|xmp)(?=[\\t\\n\\f\\r />])/gi\n\n/**\n * As HTML (text) parses tags separately (and v. strictly), we dont need to be\n * global.\n */\nconst reText = new RegExp('^' + reFlow.source, 'i')\n\n/** @type {HtmlExtension} */\nexport const gfmTagfilterHtml = {\n  exit: {\n    htmlFlowData(token) {\n      exitHtmlData.call(this, token, reFlow)\n    },\n    htmlTextData(token) {\n      exitHtmlData.call(this, token, reText)\n    }\n  }\n}\n\n/**\n * @this {CompileContext}\n * @param {Token} token\n * @param {RegExp} filter\n */\nfunction exitHtmlData(token, filter) {\n  let value = this.sliceSerialize(token)\n\n  if (this.options.allowDangerousHtml) {\n    value = value.replace(filter, '&lt;$1$2')\n  }\n\n  this.raw(this.encode(value))\n}\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEndingOrSpace,\n  markdownLineEnding\n} from 'micromark-util-character'\nconst tasklistCheck = {\n  tokenize: tokenizeTasklistCheck\n}\nexport const gfmTaskListItem = {\n  text: {\n    [91]: tasklistCheck\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeTasklistCheck(effects, ok, nok) {\n  const self = this\n  return open\n  /** @type {State} */\n\n  function open(code) {\n    if (\n      // Exit if theres stuff before.\n      self.previous !== null || // Exit if not in the first content that is the first child of a list\n      // item.\n      !self._gfmTasklistFirstContentOfListItem\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('taskListCheck')\n    effects.enter('taskListCheckMarker')\n    effects.consume(code)\n    effects.exit('taskListCheckMarker')\n    return inside\n  }\n  /** @type {State} */\n\n  function inside(code) {\n    // To match how GH works in comments, use `markdownSpace` (`[ \\t]`) instead\n    // of `markdownLineEndingOrSpace` (`[ \\t\\r\\n]`).\n    if (markdownLineEndingOrSpace(code)) {\n      effects.enter('taskListCheckValueUnchecked')\n      effects.consume(code)\n      effects.exit('taskListCheckValueUnchecked')\n      return close\n    }\n\n    if (code === 88 || code === 120) {\n      effects.enter('taskListCheckValueChecked')\n      effects.consume(code)\n      effects.exit('taskListCheckValueChecked')\n      return close\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function close(code) {\n    if (code === 93) {\n      effects.enter('taskListCheckMarker')\n      effects.consume(code)\n      effects.exit('taskListCheckMarker')\n      effects.exit('taskListCheck')\n      return effects.check(\n        {\n          tokenize: spaceThenNonSpace\n        },\n        ok,\n        nok\n      )\n    }\n\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction spaceThenNonSpace(effects, ok, nok) {\n  const self = this\n  return factorySpace(effects, after, 'whitespace')\n  /** @type {State} */\n\n  function after(code) {\n    const tail = self.events[self.events.length - 1]\n    return (\n      // We either found spaces\n      ((tail && tail[1].type === 'whitespace') || // or it was followed by a line ending, in which case, there has to be\n        // non-whitespace after that line ending, because otherwise wed get an\n        // EOF as the content is closed with blank lines.\n        markdownLineEnding(code)) &&\n        code !== null\n        ? ok(code)\n        : nok(code)\n    )\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('micromark-extension-gfm-strikethrough').Options} Options\n * @typedef {import('micromark-extension-gfm-footnote').HtmlOptions} HtmlOptions\n */\n\nimport {\n  combineExtensions,\n  combineHtmlExtensions\n} from 'micromark-util-combine-extensions'\nimport {\n  gfmAutolinkLiteral,\n  gfmAutolinkLiteralHtml\n} from 'micromark-extension-gfm-autolink-literal'\nimport {gfmFootnote, gfmFootnoteHtml} from 'micromark-extension-gfm-footnote'\nimport {\n  gfmStrikethrough,\n  gfmStrikethroughHtml\n} from 'micromark-extension-gfm-strikethrough'\nimport {gfmTable, gfmTableHtml} from 'micromark-extension-gfm-table'\nimport {gfmTagfilterHtml} from 'micromark-extension-gfm-tagfilter'\nimport {\n  gfmTaskListItem,\n  gfmTaskListItemHtml\n} from 'micromark-extension-gfm-task-list-item'\n\n/**\n * Support GFM or markdown on github.com.\n *\n * @param {Options} [options]\n * @returns {Extension}\n */\nexport function gfm(options) {\n  return combineExtensions([\n    gfmAutolinkLiteral,\n    gfmFootnote(),\n    gfmStrikethrough(options),\n    gfmTable,\n    gfmTaskListItem\n  ])\n}\n\n/**\n * Support to compile GFM to HTML.\n *\n * @param {HtmlOptions} [options]\n * @returns {HtmlExtension}\n */\nexport function gfmHtml(options) {\n  return combineHtmlExtensions([\n    gfmAutolinkLiteralHtml,\n    gfmFootnoteHtml(options),\n    gfmStrikethroughHtml,\n    gfmTableHtml,\n    gfmTagfilterHtml,\n    gfmTaskListItemHtml\n  ])\n}\n","/**\n * Count how often a character (or substring) is used in a string.\n *\n * @param {string} value\n *   Value to search in.\n * @param {string} character\n *   Character (or substring) to look for.\n * @return {number}\n *   Number of times `character` occurred in `value`.\n */\nexport function ccount(value, character) {\n  const source = String(value)\n\n  if (typeof character !== 'string') {\n    throw new TypeError('Expected character')\n  }\n\n  let count = 0\n  let index = source.indexOf(character)\n\n  while (index !== -1) {\n    count++\n    index = source.indexOf(character, index + character.length)\n  }\n\n  return count\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */\n\n/**\n * @typedef {CONTINUE|SKIP|EXIT} Action Union of the action types\n * @typedef {number} Index Move to the sibling at index next (after node itself is completely traversed). Useful if mutating the tree, such as removing the node the visitor is currently on, or any of its previous siblings (or next siblings, in case of reverse) Results less than 0 or greater than or equal to children.length stop traversing the parent\n * @typedef {[(Action|null|undefined|void)?, (Index|null|undefined)?]} ActionTuple List with one or two values, the first an action, the second an index.\n * @typedef {null|undefined|Action|Index|ActionTuple|void} VisitorResult Any value that can be returned from a visitor\n */\n\n/**\n * Invoked when a node (matching test, if given) is found.\n * Visitors are free to transform node.\n * They can also transform the parent of node (the last of ancestors).\n * Replacing node itself, if `SKIP` is not returned, still causes its descendants to be visited.\n * If adding or removing previous siblings (or next siblings, in case of reverse) of node,\n * visitor should return a new index (number) to specify the sibling to traverse after node is traversed.\n * Adding or removing next siblings of node (or previous siblings, in case of reverse)\n * is handled as expected without needing to return a new index.\n * Removing the children property of an ancestor still results in them being traversed.\n *\n * @template {Node} V\n * @callback Visitor\n * @param {V} node Found node\n * @param {Array.<Parent>} ancestors Ancestors of node\n * @returns {VisitorResult}\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from './color.js'\n\n/**\n * Continue traversing as normal\n */\nexport const CONTINUE = true\n/**\n * Do not traverse this nodes children\n */\nexport const SKIP = 'skip'\n/**\n * Stop traversing immediately\n */\nexport const EXIT = false\n\nexport const visitParents =\n  /**\n   * @type {(\n   *   (<T extends Node>(tree: Node, test: T['type']|Partial<T>|import('unist-util-is').TestFunctionPredicate<T>|Array.<T['type']|Partial<T>|import('unist-util-is').TestFunctionPredicate<T>>, visitor: Visitor<T>, reverse?: boolean) => void) &\n   *   ((tree: Node, test: Test, visitor: Visitor<Node>, reverse?: boolean) => void) &\n   *   ((tree: Node, visitor: Visitor<Node>, reverse?: boolean) => void)\n   * )}\n   */\n  (\n    /**\n     * Visit children of tree which pass a test\n     *\n     * @param {Node} tree Abstract syntax tree to walk\n     * @param {Test} test test Test node\n     * @param {Visitor<Node>} visitor Function to run for each node\n     * @param {boolean} [reverse] Fisit the tree in reverse, defaults to false\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        // @ts-ignore no visitor given, so `visitor` is test.\n        visitor = test\n        test = null\n      }\n\n      var is = convert(test)\n      var step = reverse ? -1 : 1\n\n      factory(tree, null, [])()\n\n      /**\n       * @param {Node} node\n       * @param {number?} index\n       * @param {Array.<Parent>} parents\n       */\n      function factory(node, index, parents) {\n        /** @type {Object.<string, unknown>} */\n        var value = typeof node === 'object' && node !== null ? node : {}\n        /** @type {string} */\n        var name\n\n        if (typeof value.type === 'string') {\n          name =\n            typeof value.tagName === 'string'\n              ? value.tagName\n              : typeof value.name === 'string'\n              ? value.name\n              : undefined\n\n          Object.defineProperty(visit, 'name', {\n            value:\n              'node (' +\n              color(value.type + (name ? '<' + name + '>' : '')) +\n              ')'\n          })\n        }\n\n        return visit\n\n        function visit() {\n          /** @type {ActionTuple} */\n          var result = []\n          /** @type {ActionTuple} */\n          var subresult\n          /** @type {number} */\n          var offset\n          /** @type {Array.<Parent>} */\n          var grandparents\n\n          if (!test || is(node, index, parents[parents.length - 1] || null)) {\n            result = toResult(visitor(node, parents))\n\n            if (result[0] === EXIT) {\n              return result\n            }\n          }\n\n          if (node.children && result[0] !== SKIP) {\n            // @ts-ignore looks like a parent.\n            offset = (reverse ? node.children.length : -1) + step\n            // @ts-ignore looks like a parent.\n            grandparents = parents.concat(node)\n\n            // @ts-ignore looks like a parent.\n            while (offset > -1 && offset < node.children.length) {\n              subresult = factory(node.children[offset], offset, grandparents)()\n\n              if (subresult[0] === EXIT) {\n                return subresult\n              }\n\n              offset =\n                typeof subresult[1] === 'number' ? subresult[1] : offset + step\n            }\n          }\n\n          return result\n        }\n      }\n    }\n  )\n\n/**\n * @param {VisitorResult} value\n * @returns {ActionTuple}\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return [value]\n}\n","/**\n * @typedef Options Configuration.\n * @property {Test} [ignore] `unist-util-is` test used to assert parents\n *\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').Text} Text\n * @typedef {Content|Root} Node\n * @typedef {Extract<Node, import('mdast').Parent>} Parent\n *\n * @typedef {import('unist-util-visit-parents').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n *\n * @typedef RegExpMatchObject\n * @property {number} index\n * @property {string} input\n *\n * @typedef {string|RegExp} Find\n * @typedef {string|ReplaceFunction} Replace\n *\n * @typedef {[Find, Replace]} FindAndReplaceTuple\n * @typedef {Object.<string, Replace>} FindAndReplaceSchema\n * @typedef {Array.<FindAndReplaceTuple>} FindAndReplaceList\n *\n * @typedef {[RegExp, ReplaceFunction]} Pair\n * @typedef {Array.<Pair>} Pairs\n */\n\n/**\n * @callback ReplaceFunction\n * @param {...any} parameters\n * @returns {Array.<PhrasingContent>|PhrasingContent|string|false|undefined|null}\n */\n\nimport escape from 'escape-string-regexp'\nimport {visitParents} from 'unist-util-visit-parents'\nimport {convert} from 'unist-util-is'\n\nconst own = {}.hasOwnProperty\n\n/**\n * @param tree mdast tree\n * @param find Value to find and remove. When `string`, escaped and made into a global `RegExp`\n * @param [replace] Value to insert.\n *   * When `string`, turned into a Text node.\n *   * When `Function`, called with the results of calling `RegExp.exec` as\n *     arguments, in which case it can return a single or a list of `Node`,\n *     a `string` (which is wrapped in a `Text` node), or `false` to not replace\n * @param [options] Configuration.\n */\nexport const findAndReplace =\n  /**\n   * @type {(\n   *   ((tree: Node, find: Find, replace?: Replace, options?: Options) => Node) &\n   *   ((tree: Node, schema: FindAndReplaceSchema|FindAndReplaceList, options?: Options) => Node)\n   * )}\n   **/\n  (\n    /**\n     * @param {Node} tree\n     * @param {Find|FindAndReplaceSchema|FindAndReplaceList} find\n     * @param {Replace|Options} [replace]\n     * @param {Options} [options]\n     */\n    function (tree, find, replace, options) {\n      /** @type {Options|undefined} */\n      let settings\n      /** @type {FindAndReplaceSchema|FindAndReplaceList} */\n      let schema\n\n      if (typeof find === 'string' || find instanceof RegExp) {\n        // @ts-expect-error dont expect options twice.\n        schema = [[find, replace]]\n        settings = options\n      } else {\n        schema = find\n        // @ts-expect-error dont expect replace twice.\n        settings = replace\n      }\n\n      if (!settings) {\n        settings = {}\n      }\n\n      const ignored = convert(settings.ignore || [])\n      const pairs = toPairs(schema)\n      let pairIndex = -1\n\n      while (++pairIndex < pairs.length) {\n        visitParents(tree, 'text', visitor)\n      }\n\n      return tree\n\n      /** @type {import('unist-util-visit-parents').Visitor<Text>} */\n      function visitor(node, parents) {\n        let index = -1\n        /** @type {Parent|undefined} */\n        let grandparent\n\n        while (++index < parents.length) {\n          const parent = /** @type {Parent} */ (parents[index])\n\n          if (\n            ignored(\n              parent,\n              // @ts-expect-error mdast vs. unist parent.\n              grandparent ? grandparent.children.indexOf(parent) : undefined,\n              grandparent\n            )\n          ) {\n            return\n          }\n\n          grandparent = parent\n        }\n\n        if (grandparent) {\n          return handler(node, grandparent)\n        }\n      }\n\n      /**\n       * @param {Text} node\n       * @param {Parent} parent\n       * @returns {VisitorResult}\n       */\n      function handler(node, parent) {\n        const find = pairs[pairIndex][0]\n        const replace = pairs[pairIndex][1]\n        let start = 0\n        // @ts-expect-error: TS is wrong, some of these children can be text.\n        let index = parent.children.indexOf(node)\n        /** @type {Array.<PhrasingContent>} */\n        let nodes = []\n        /** @type {number|undefined} */\n        let position\n\n        find.lastIndex = 0\n\n        let match = find.exec(node.value)\n\n        while (match) {\n          position = match.index\n          // @ts-expect-error this is perfectly fine, typescript.\n          let value = replace(...match, {\n            index: match.index,\n            input: match.input\n          })\n\n          if (typeof value === 'string') {\n            value = value.length > 0 ? {type: 'text', value} : undefined\n          }\n\n          if (value !== false) {\n            if (start !== position) {\n              nodes.push({\n                type: 'text',\n                value: node.value.slice(start, position)\n              })\n            }\n\n            if (Array.isArray(value)) {\n              nodes.push(...value)\n            } else if (value) {\n              nodes.push(value)\n            }\n\n            start = position + match[0].length\n          }\n\n          if (!find.global) {\n            break\n          }\n\n          match = find.exec(node.value)\n        }\n\n        if (position === undefined) {\n          nodes = [node]\n          index--\n        } else {\n          if (start < node.value.length) {\n            nodes.push({type: 'text', value: node.value.slice(start)})\n          }\n\n          parent.children.splice(index, 1, ...nodes)\n        }\n\n        return index + nodes.length + 1\n      }\n    }\n  )\n\n/**\n * @param {FindAndReplaceSchema|FindAndReplaceList} schema\n * @returns {Pairs}\n */\nfunction toPairs(schema) {\n  /** @type {Pairs} */\n  const result = []\n\n  if (typeof schema !== 'object') {\n    throw new TypeError('Expected array or object as schema')\n  }\n\n  if (Array.isArray(schema)) {\n    let index = -1\n\n    while (++index < schema.length) {\n      result.push([\n        toExpression(schema[index][0]),\n        toFunction(schema[index][1])\n      ])\n    }\n  } else {\n    /** @type {string} */\n    let key\n\n    for (key in schema) {\n      if (own.call(schema, key)) {\n        result.push([toExpression(key), toFunction(schema[key])])\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * @param {Find} find\n * @returns {RegExp}\n */\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find\n}\n\n/**\n * @param {Replace} replace\n * @returns {ReplaceFunction}\n */\nfunction toFunction(replace) {\n  return typeof replace === 'function' ? replace : () => replace\n}\n","export default function escapeStringRegexp(string) {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Escape characters with special meaning either inside or outside character sets.\n\t// Use a simple backslash escape when its always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns stricter grammar.\n\treturn string\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\t\t.replace(/-/g, '\\\\x2d');\n}\n","/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Transform} FromMarkdownTransform\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown/lib/types.js').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-find-and-replace').ReplaceFunction} ReplaceFunction\n * @typedef {import('mdast-util-find-and-replace').RegExpMatchObject} RegExpMatchObject\n * @typedef {import('mdast-util-find-and-replace').PhrasingContent} PhrasingContent\n */\n\nimport {ccount} from 'ccount'\nimport {findAndReplace} from 'mdast-util-find-and-replace'\nimport {unicodePunctuation, unicodeWhitespace} from 'micromark-util-character'\n\nconst inConstruct = 'phrasing'\nconst notInConstruct = ['autolink', 'link', 'image', 'label']\n\n/** @type {FromMarkdownExtension} */\nexport const gfmAutolinkLiteralFromMarkdown = {\n  transforms: [transformGfmAutolinkLiterals],\n  enter: {\n    literalAutolink: enterLiteralAutolink,\n    literalAutolinkEmail: enterLiteralAutolinkValue,\n    literalAutolinkHttp: enterLiteralAutolinkValue,\n    literalAutolinkWww: enterLiteralAutolinkValue\n  },\n  exit: {\n    literalAutolink: exitLiteralAutolink,\n    literalAutolinkEmail: exitLiteralAutolinkEmail,\n    literalAutolinkHttp: exitLiteralAutolinkHttp,\n    literalAutolinkWww: exitLiteralAutolinkWww\n  }\n}\n\n/** @type {ToMarkdownExtension} */\nexport const gfmAutolinkLiteralToMarkdown = {\n  unsafe: [\n    {\n      character: '@',\n      before: '[+\\\\-.\\\\w]',\n      after: '[\\\\-.\\\\w]',\n      inConstruct,\n      notInConstruct\n    },\n    {\n      character: '.',\n      before: '[Ww]',\n      after: '[\\\\-.\\\\w]',\n      inConstruct,\n      notInConstruct\n    },\n    {character: ':', before: '[ps]', after: '\\\\/', inConstruct, notInConstruct}\n  ]\n}\n\n/** @type {FromMarkdownHandle} */\nfunction enterLiteralAutolink(token) {\n  this.enter({type: 'link', title: null, url: '', children: []}, token)\n}\n\n/** @type {FromMarkdownHandle} */\nfunction enterLiteralAutolinkValue(token) {\n  this.config.enter.autolinkProtocol.call(this, token)\n}\n\n/** @type {FromMarkdownHandle} */\nfunction exitLiteralAutolinkHttp(token) {\n  this.config.exit.autolinkProtocol.call(this, token)\n}\n\n/** @type {FromMarkdownHandle} */\nfunction exitLiteralAutolinkWww(token) {\n  this.config.exit.data.call(this, token)\n  const node = /** @type {Link} */ (this.stack[this.stack.length - 1])\n  node.url = 'http://' + this.sliceSerialize(token)\n}\n\n/** @type {FromMarkdownHandle} */\nfunction exitLiteralAutolinkEmail(token) {\n  this.config.exit.autolinkEmail.call(this, token)\n}\n\n/** @type {FromMarkdownHandle} */\nfunction exitLiteralAutolink(token) {\n  this.exit(token)\n}\n\n/** @type {FromMarkdownTransform} */\nfunction transformGfmAutolinkLiterals(tree) {\n  findAndReplace(\n    tree,\n    [\n      [/(https?:\\/\\/|www(?=\\.))([-.\\w]+)([^ \\t\\r\\n]*)/gi, findUrl],\n      [/([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)/g, findEmail]\n    ],\n    {ignore: ['link', 'linkReference']}\n  )\n}\n\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} protocol\n * @param {string} domain\n * @param {string} path\n * @param {RegExpMatchObject} match\n */\n// eslint-disable-next-line max-params\nfunction findUrl(_, protocol, domain, path, match) {\n  let prefix = ''\n\n  // Not an expected previous character.\n  if (!previous(match)) {\n    return false\n  }\n\n  // Treat `www` as part of the domain.\n  if (/^w/i.test(protocol)) {\n    domain = protocol + domain\n    protocol = ''\n    prefix = 'http://'\n  }\n\n  if (!isCorrectDomain(domain)) {\n    return false\n  }\n\n  const parts = splitUrl(domain + path)\n\n  if (!parts[0]) return false\n\n  /** @type {PhrasingContent} */\n  const result = {\n    type: 'link',\n    title: null,\n    url: prefix + protocol + parts[0],\n    children: [{type: 'text', value: protocol + parts[0]}]\n  }\n\n  if (parts[1]) {\n    return [result, {type: 'text', value: parts[1]}]\n  }\n\n  return result\n}\n\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} atext\n * @param {string} label\n * @param {RegExpMatchObject} match\n */\nfunction findEmail(_, atext, label, match) {\n  if (\n    // Not an expected previous character.\n    !previous(match, true) ||\n    // Label ends in not allowed character.\n    /[_-\\d]$/.test(label)\n  ) {\n    return false\n  }\n\n  return {\n    type: 'link',\n    title: null,\n    url: 'mailto:' + atext + '@' + label,\n    children: [{type: 'text', value: atext + '@' + label}]\n  }\n}\n\n/**\n * @param {string} domain\n * @returns {boolean}\n */\nfunction isCorrectDomain(domain) {\n  const parts = domain.split('.')\n\n  if (\n    parts.length < 2 ||\n    (parts[parts.length - 1] &&\n      (/_/.test(parts[parts.length - 1]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 1]))) ||\n    (parts[parts.length - 2] &&\n      (/_/.test(parts[parts.length - 2]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 2])))\n  ) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @param {string} url\n * @returns {[string, string|undefined]}\n */\nfunction splitUrl(url) {\n  const trailExec = /[!\"&'),.:;<>?\\]}]+$/.exec(url)\n  /** @type {number} */\n  let closingParenIndex\n  /** @type {number} */\n  let openingParens\n  /** @type {number} */\n  let closingParens\n  /** @type {string|undefined} */\n  let trail\n\n  if (trailExec) {\n    url = url.slice(0, trailExec.index)\n    trail = trailExec[0]\n    closingParenIndex = trail.indexOf(')')\n    openingParens = ccount(url, '(')\n    closingParens = ccount(url, ')')\n\n    while (closingParenIndex !== -1 && openingParens > closingParens) {\n      url += trail.slice(0, closingParenIndex + 1)\n      trail = trail.slice(closingParenIndex + 1)\n      closingParenIndex = trail.indexOf(')')\n      closingParens++\n    }\n  }\n\n  return [url, trail]\n}\n\n/**\n * @param {RegExpMatchObject} match\n * @param {boolean} [email=false]\n * @returns {boolean}\n */\nfunction previous(match, email) {\n  const code = match.input.charCodeAt(match.index - 1)\n\n  return (\n    (match.index === 0 ||\n      unicodeWhitespace(code) ||\n      unicodePunctuation(code)) &&\n    (!email || code !== 47)\n  )\n}\n","/**\n * @typedef {import('mdast').Association} Association\n */\n\nimport {decodeString} from 'micromark-util-decode-string'\n\n/**\n * The `label` of an association is the string value: character escapes and\n * references work, and casing is intact.\n * The `identifier` is used to match one association to another: controversially,\n * character escapes and references dont work in this matching: `&copy;` does\n * not match ``, and `\\+` does not match `+`.\n * But casing is ignored (and whitespace) is trimmed and collapsed: ` A\\nb`\n * matches `a b`.\n * So, we do prefer the label when figuring out how were going to serialize:\n * it has whitespace, casing, and we can ignore most useless character escapes\n * and all character references.\n *\n * @param {Association} node\n * @returns {string}\n */\nexport function association(node) {\n  if (node.label || !node.identifier) {\n    return node.label || ''\n  }\n\n  return decodeString(node.identifier)\n}\n","/**\n * @typedef {import('unist').Point} Point\n * @typedef {import('../types.js').TrackFields} TrackFields\n */\n\n/**\n * Functions to track output positions.\n * This info isnt used yet but suchs functionality allows line wrapping,\n * and theoretically source maps (though, is there practical use in that?).\n *\n * @param {TrackFields} options_\n */\nexport function track(options_) {\n  // Defaults are used to prevent crashes when older utilities somehow activate\n  // this code.\n  /* c8 ignore next 5 */\n  const options = options_ || {}\n  const now = options.now || {}\n  let lineShift = options.lineShift || 0\n  let line = now.line || 1\n  let column = now.column || 1\n\n  return {move, current, shift}\n\n  /**\n   * Get the current tracked info.\n   *\n   * @returns {{now: Point, lineShift: number}}\n   */\n  function current() {\n    return {now: {line, column}, lineShift}\n  }\n\n  /**\n   * Define an increased line shift (the typical indent for lines).\n   *\n   * @param {number} value\n   */\n  function shift(value) {\n    lineShift += value\n  }\n\n  /**\n   * Move past a string.\n   *\n   * @param {string} value\n   * @returns {string}\n   */\n  function move(value = '') {\n    const chunks = value.split(/\\r?\\n|\\r/g)\n    const tail = chunks[chunks.length - 1]\n    line += chunks.length - 1\n    column =\n      chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift\n    return value\n  }\n}\n","/**\n * @typedef {import('../types.js').Node} Node\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').Join} Join\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').TrackFields} TrackFields\n */\n\nimport {track} from './track.js'\n\n/**\n * @param {Parent} parent\n * @param {Context} context\n * @param {TrackFields} safeOptions\n * @returns {string}\n */\nexport function containerFlow(parent, context, safeOptions) {\n  const indexStack = context.indexStack\n  const children = parent.children || []\n  const tracker = track(safeOptions)\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n\n  indexStack.push(-1)\n\n  while (++index < children.length) {\n    const child = children[index]\n\n    indexStack[indexStack.length - 1] = index\n\n    results.push(\n      tracker.move(\n        context.handle(child, parent, context, {\n          before: '\\n',\n          after: '\\n',\n          ...tracker.current()\n        })\n      )\n    )\n\n    if (child.type !== 'list') {\n      context.bulletLastUsed = undefined\n    }\n\n    if (index < children.length - 1) {\n      results.push(tracker.move(between(child, children[index + 1])))\n    }\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n\n  /**\n   * @param {Node} left\n   * @param {Node} right\n   * @returns {string}\n   */\n  function between(left, right) {\n    let index = context.join.length\n\n    while (index--) {\n      const result = context.join[index](left, right, parent, context)\n\n      if (result === true || result === 1) {\n        break\n      }\n\n      if (typeof result === 'number') {\n        return '\\n'.repeat(1 + result)\n      }\n\n      if (result === false) {\n        return '\\n\\n<!---->\\n\\n'\n      }\n    }\n\n    return '\\n\\n'\n  }\n}\n","/**\n * @callback Map\n * @param {string} value\n * @param {number} line\n * @param {boolean} blank\n * @returns {string}\n */\n\nconst eol = /\\r?\\n|\\r/g\n\n/**\n * @param {string} value\n * @param {Map} map\n * @returns {string}\n */\nexport function indentLines(value, map) {\n  /** @type {Array<string>} */\n  const result = []\n  let start = 0\n  let line = 0\n  /** @type {RegExpExecArray|null} */\n  let match\n\n  while ((match = eol.exec(value))) {\n    one(value.slice(start, match.index))\n    result.push(match[0])\n    start = match.index + match[0].length\n    line++\n  }\n\n  one(value.slice(start))\n\n  return result.join('')\n\n  /**\n   * @param {string} value\n   */\n  function one(value) {\n    result.push(map(value, line, !value))\n  }\n}\n","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n */\n\n/**\n * @param {Unsafe} pattern\n * @returns {RegExp}\n */\nexport function patternCompile(pattern) {\n  if (!pattern._compiled) {\n    const before =\n      (pattern.atBreak ? '[\\\\r\\\\n][\\\\t ]*' : '') +\n      (pattern.before ? '(?:' + pattern.before + ')' : '')\n\n    pattern._compiled = new RegExp(\n      (before ? '(' + before + ')' : '') +\n        (/[|\\\\{}()[\\]^$+*?.-]/.test(pattern.character) ? '\\\\' : '') +\n        pattern.character +\n        (pattern.after ? '(?:' + pattern.after + ')' : ''),\n      'g'\n    )\n  }\n\n  return pattern._compiled\n}\n","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n */\n\n/**\n * @param {Array<string>} stack\n * @param {Unsafe} pattern\n * @returns {boolean}\n */\nexport function patternInScope(stack, pattern) {\n  return (\n    listInScope(stack, pattern.inConstruct, true) &&\n    !listInScope(stack, pattern.notInConstruct, false)\n  )\n}\n\n/**\n * @param {Array<string>} stack\n * @param {Unsafe['inConstruct']} list\n * @param {boolean} none\n * @returns {boolean}\n */\nfunction listInScope(stack, list, none) {\n  if (!list) {\n    return none\n  }\n\n  if (typeof list === 'string') {\n    list = [list]\n  }\n\n  let index = -1\n\n  while (++index < list.length) {\n    if (stack.includes(list[index])) {\n      return true\n    }\n  }\n\n  return false\n}\n","/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').SafeOptions} SafeOptions\n */\n\nimport {patternCompile} from './pattern-compile.js'\nimport {patternInScope} from './pattern-in-scope.js'\n\n/**\n * @param {Context} context\n * @param {string|null|undefined} input\n * @param {SafeOptions & {encode?: Array<string>}} config\n * @returns {string}\n */\nexport function safe(context, input, config) {\n  const value = (config.before || '') + (input || '') + (config.after || '')\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\n  const infos = {}\n  let index = -1\n\n  while (++index < context.unsafe.length) {\n    const pattern = context.unsafe[index]\n\n    if (!patternInScope(context.stack, pattern)) {\n      continue\n    }\n\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray|null} */\n    let match\n\n    while ((match = expression.exec(value))) {\n      const before = 'before' in pattern || Boolean(pattern.atBreak)\n      const after = 'after' in pattern\n      const position = match.index + (before ? match[1].length : 0)\n\n      if (positions.includes(position)) {\n        if (infos[position].before && !before) {\n          infos[position].before = false\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false\n        }\n      } else {\n        positions.push(position)\n        infos[position] = {before, after}\n      }\n    }\n  }\n\n  positions.sort(numerical)\n\n  let start = config.before ? config.before.length : 0\n  const end = value.length - (config.after ? config.after.length : 0)\n  index = -1\n\n  while (++index < positions.length) {\n    const position = positions[index]\n\n    // Character before or after matched:\n    if (position < start || position >= end) {\n      continue\n    }\n\n    // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n    if (\n      (position + 1 < end &&\n        positions[index + 1] === position + 1 &&\n        infos[position].after &&\n        !infos[position + 1].before &&\n        !infos[position + 1].after) ||\n      (positions[index - 1] === position - 1 &&\n        infos[position].before &&\n        !infos[position - 1].before &&\n        !infos[position - 1].after)\n    ) {\n      continue\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\n    }\n\n    start = position\n\n    if (\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\n      (!config.encode || !config.encode.includes(value.charAt(position)))\n    ) {\n      // Character escape.\n      result.push('\\\\')\n    } else {\n      // Character reference.\n      result.push(\n        '&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';'\n      )\n      start++\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\n\n  return result.join('')\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction numerical(a, b) {\n  return a - b\n}\n\n/**\n * @param {string} value\n * @param {string} after\n * @returns {string}\n */\nfunction escapeBackslashes(value, after) {\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const results = []\n  const whole = value + after\n  let index = -1\n  let start = 0\n  /** @type {RegExpExecArray|null} */\n  let match\n\n  while ((match = expression.exec(whole))) {\n    positions.push(match.index)\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]))\n    }\n\n    results.push('\\\\')\n    start = positions[index]\n  }\n\n  results.push(value.slice(start))\n\n  return results.join('')\n}\n","/**\n * @typedef {import('mdast').FootnoteReference} FootnoteReference\n * @typedef {import('mdast').FootnoteDefinition} FootnoteDefinition\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Map} Map\n */\n\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {association} from 'mdast-util-to-markdown/lib/util/association.js'\nimport {containerFlow} from 'mdast-util-to-markdown/lib/util/container-flow.js'\nimport {indentLines} from 'mdast-util-to-markdown/lib/util/indent-lines.js'\nimport {safe} from 'mdast-util-to-markdown/lib/util/safe.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\n/**\n * @returns {FromMarkdownExtension}\n */\nexport function gfmFootnoteFromMarkdown() {\n  return {\n    enter: {\n      gfmFootnoteDefinition: enterFootnoteDefinition,\n      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,\n      gfmFootnoteCall: enterFootnoteCall,\n      gfmFootnoteCallString: enterFootnoteCallString\n    },\n    exit: {\n      gfmFootnoteDefinition: exitFootnoteDefinition,\n      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,\n      gfmFootnoteCall: exitFootnoteCall,\n      gfmFootnoteCallString: exitFootnoteCallString\n    }\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function enterFootnoteDefinition(token) {\n    this.enter(\n      {type: 'footnoteDefinition', identifier: '', label: '', children: []},\n      token\n    )\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function enterFootnoteDefinitionLabelString() {\n    this.buffer()\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitFootnoteDefinitionLabelString(token) {\n    const label = this.resume()\n    const node = /** @type {FootnoteDefinition} */ (\n      this.stack[this.stack.length - 1]\n    )\n    node.label = label\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitFootnoteDefinition(token) {\n    this.exit(token)\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function enterFootnoteCall(token) {\n    this.enter({type: 'footnoteReference', identifier: '', label: ''}, token)\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function enterFootnoteCallString() {\n    this.buffer()\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitFootnoteCallString(token) {\n    const label = this.resume()\n    const node = /** @type {FootnoteDefinition} */ (\n      this.stack[this.stack.length - 1]\n    )\n    node.label = label\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitFootnoteCall(token) {\n    this.exit(token)\n  }\n}\n\n/**\n * @returns {ToMarkdownExtension}\n */\nexport function gfmFootnoteToMarkdown() {\n  footnoteReference.peek = footnoteReferencePeek\n\n  return {\n    // This is on by default already.\n    unsafe: [{character: '[', inConstruct: ['phrasing', 'label', 'reference']}],\n    handlers: {footnoteDefinition, footnoteReference}\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {FootnoteReference} node\n   */\n  function footnoteReference(node, _, context, safeOptions) {\n    const tracker = track(safeOptions)\n    let value = tracker.move('[^')\n    const exit = context.enter('footnoteReference')\n    const subexit = context.enter('reference')\n    value += tracker.move(\n      safe(context, association(node), {\n        ...tracker.current(),\n        before: value,\n        after: ']'\n      })\n    )\n    subexit()\n    exit()\n    value += tracker.move(']')\n    return value\n  }\n\n  /** @type {ToMarkdownHandle} */\n  function footnoteReferencePeek() {\n    return '['\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {FootnoteDefinition} node\n   */\n  function footnoteDefinition(node, _, context, safeOptions) {\n    const tracker = track(safeOptions)\n    let value = tracker.move('[^')\n    const exit = context.enter('footnoteDefinition')\n    const subexit = context.enter('label')\n    value += tracker.move(\n      safe(context, association(node), {\n        ...tracker.current(),\n        before: value,\n        after: ']'\n      })\n    )\n    subexit()\n    value += tracker.move(\n      ']:' + (node.children && node.children.length > 0 ? ' ' : '')\n    )\n    tracker.shift(4)\n    value += tracker.move(\n      indentLines(containerFlow(node, context, tracker.current()), map)\n    )\n    exit()\n\n    return value\n\n    /** @type {Map} */\n    function map(line, index, blank) {\n      if (index) {\n        return (blank ? '' : '    ') + line\n      }\n\n      return line\n    }\n  }\n}\n","/**\n * @typedef {import('../types.js').Node} Node\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').SafeOptions} SafeOptions\n * @typedef {import('../types.js').Context} Context\n */\n\nimport {track} from './track.js'\n\n/**\n * @param {Parent} parent\n * @param {Context} context\n * @param {SafeOptions} safeOptions\n * @returns {string}\n */\nexport function containerPhrasing(parent, context, safeOptions) {\n  const indexStack = context.indexStack\n  const children = parent.children || []\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n  let before = safeOptions.before\n\n  indexStack.push(-1)\n  let tracker = track(safeOptions)\n\n  while (++index < children.length) {\n    const child = children[index]\n    /** @type {string} */\n    let after\n\n    indexStack[indexStack.length - 1] = index\n\n    if (index + 1 < children.length) {\n      // @ts-expect-error: hush, its actually a `zwitch`.\n      let handle = context.handle.handlers[children[index + 1].type]\n      if (handle && handle.peek) handle = handle.peek\n      after = handle\n        ? handle(children[index + 1], parent, context, {\n            before: '',\n            after: '',\n            ...tracker.current()\n          }).charAt(0)\n        : ''\n    } else {\n      after = safeOptions.after\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When wed serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we cant escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (\n      results.length > 0 &&\n      (before === '\\r' || before === '\\n') &&\n      child.type === 'html'\n    ) {\n      results[results.length - 1] = results[results.length - 1].replace(\n        /(\\r?\\n|\\r)$/,\n        ' '\n      )\n      before = ' '\n\n      // To do: does this work to reset tracker?\n      tracker = track(safeOptions)\n      tracker.move(results.join(''))\n    }\n\n    results.push(\n      tracker.move(\n        context.handle(child, parent, context, {\n          ...tracker.current(),\n          before,\n          after\n        })\n      )\n    )\n\n    before = results[results.length - 1].slice(-1)\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n","/**\n * @typedef {import('mdast').Delete} Delete\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\nimport {containerPhrasing} from 'mdast-util-to-markdown/lib/util/container-phrasing.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\n/** @type {FromMarkdownExtension} */\nexport const gfmStrikethroughFromMarkdown = {\n  canContainEols: ['delete'],\n  enter: {strikethrough: enterStrikethrough},\n  exit: {strikethrough: exitStrikethrough}\n}\n\n/** @type {ToMarkdownExtension} */\nexport const gfmStrikethroughToMarkdown = {\n  unsafe: [{character: '~', inConstruct: 'phrasing'}],\n  handlers: {delete: handleDelete}\n}\n\nhandleDelete.peek = peekDelete\n\n/** @type {FromMarkdownHandle} */\nfunction enterStrikethrough(token) {\n  this.enter({type: 'delete', children: []}, token)\n}\n\n/** @type {FromMarkdownHandle} */\nfunction exitStrikethrough(token) {\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {Delete} node\n */\nfunction handleDelete(node, _, context, safeOptions) {\n  const tracker = track(safeOptions)\n  const exit = context.enter('emphasis')\n  let value = tracker.move('~~')\n  value += containerPhrasing(node, context, {\n    ...tracker.current(),\n    before: value,\n    after: '~'\n  })\n  value += tracker.move('~~')\n  exit()\n  return value\n}\n\n/** @type {ToMarkdownHandle} */\nfunction peekDelete() {\n  return '~'\n}\n","/**\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('../types.js').Handle} Handle\n */\n\nimport {patternCompile} from '../util/pattern-compile.js'\n\ninlineCode.peek = inlineCodePeek\n\n/**\n * @type {Handle}\n * @param {InlineCode} node\n */\nexport function inlineCode(node, _, context) {\n  let value = node.value || ''\n  let sequence = '`'\n  let index = -1\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs dont count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) || /^`|`$/.test(value))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We cant escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < context.unsafe.length) {\n    const pattern = context.unsafe[index]\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray|null} */\n    let match\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    while ((match = expression.exec(value))) {\n      let position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\n/**\n * @type {Handle}\n */\nfunction inlineCodePeek() {\n  return '`'\n}\n","/**\n * @typedef Options\n *   Configuration (optional).\n * @property {string|null|Array<string|null|undefined>} [align]\n *   One style for all columns, or styles for their respective columns.\n *   Each style is either `'l'` (left), `'r'` (right), or `'c'` (center).\n *   Other values are treated as `''`, which doesnt place the colon in the\n *   alignment row but does align left.\n *   *Only the lowercased first character is used, so `Right` is fine.*\n * @property {boolean} [padding=true]\n *   Whether to add a space of padding between delimiters and cells.\n *\n *   When `true`, there is padding:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there is no padding:\n *\n *   ```markdown\n *   |Alpha|B    |\n *   |-----|-----|\n *   |C    |Delta|\n *   ```\n * @property {boolean} [delimiterStart=true]\n *   Whether to begin each row with the delimiter.\n *\n *   >  **Note**: please dont use this: it could create fragile structures\n *   > that arent understandable to some markdown parsers.\n *\n *   When `true`, there are starting delimiters:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there are no starting delimiters:\n *\n *   ```markdown\n *   Alpha | B     |\n *   ----- | ----- |\n *   C     | Delta |\n *   ```\n * @property {boolean} [delimiterEnd=true]\n *   Whether to end each row with the delimiter.\n *\n *   >  **Note**: please dont use this: it could create fragile structures\n *   > that arent understandable to some markdown parsers.\n *\n *   When `true`, there are ending delimiters:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there are no ending delimiters:\n *\n *   ```markdown\n *   | Alpha | B\n *   | ----- | -----\n *   | C     | Delta\n *   ```\n * @property {boolean} [alignDelimiters=true]\n *   Whether to align the delimiters.\n *   By default, they are aligned:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   Pass `false` to make them staggered:\n *\n *   ```markdown\n *   | Alpha | B |\n *   | - | - |\n *   | C | Delta |\n *   ```\n * @property {(value: string) => number} [stringLength]\n *   Function to detect the length of table cell content.\n *   This is used when aligning the delimiters (`|`) between table cells.\n *   Full-width characters and emoji mess up delimiter alignment when viewing\n *   the markdown source.\n *   To fix this, you can pass this function, which receives the cell content\n *   and returns its visible size.\n *   Note that what is and isnt visible depends on where the text is displayed.\n *\n *   Without such a function, the following:\n *\n *   ```js\n *   markdownTable([\n *     ['Alpha', 'Bravo'],\n *     ['', 'Charlie'],\n *     ['', 'Delta']\n *   ])\n *   ```\n *\n *   Yields:\n *\n *   ```markdown\n *   | Alpha | Bravo |\n *   | - | - |\n *   |  | Charlie |\n *   |  | Delta |\n *   ```\n *\n *   With [`string-width`](https://github.com/sindresorhus/string-width):\n *\n *   ```js\n *   import stringWidth from 'string-width'\n *\n *   markdownTable(\n *     [\n *       ['Alpha', 'Bravo'],\n *       ['', 'Charlie'],\n *       ['', 'Delta']\n *     ],\n *     {stringLength: stringWidth}\n *   )\n *   ```\n *\n *   Yields:\n *\n *   ```markdown\n *   | Alpha | Bravo   |\n *   | ----- | ------- |\n *   |   | Charlie |\n *   |     | Delta   |\n *   ```\n */\n\n/**\n * @typedef {Options} MarkdownTableOptions\n * @todo\n *   Remove next major.\n */\n\n/**\n * Generate a markdown ([GFM](https://docs.github.com/en/github/writing-on-github/working-with-advanced-formatting/organizing-information-with-tables)) table..\n *\n * @param {Array<Array<string|null|undefined>>} table\n *   Table data (matrix of strings).\n * @param {Options} [options]\n *   Configuration (optional).\n * @returns {string}\n */\nexport function markdownTable(table, options = {}) {\n  const align = (options.align || []).concat()\n  const stringLength = options.stringLength || defaultStringLength\n  /** @type {Array<number>} Character codes as symbols for alignment per column. */\n  const alignments = []\n  /** @type {Array<Array<string>>} Cells per row. */\n  const cellMatrix = []\n  /** @type {Array<Array<number>>} Sizes of each cell per row. */\n  const sizeMatrix = []\n  /** @type {Array<number>} */\n  const longestCellByColumn = []\n  let mostCellsPerRow = 0\n  let rowIndex = -1\n\n  // This is a superfluous loop if we dont align delimiters, but otherwise wed\n  // do superfluous work when aligning, so optimize for aligning.\n  while (++rowIndex < table.length) {\n    /** @type {Array<string>} */\n    const row = []\n    /** @type {Array<number>} */\n    const sizes = []\n    let columnIndex = -1\n\n    if (table[rowIndex].length > mostCellsPerRow) {\n      mostCellsPerRow = table[rowIndex].length\n    }\n\n    while (++columnIndex < table[rowIndex].length) {\n      const cell = serialize(table[rowIndex][columnIndex])\n\n      if (options.alignDelimiters !== false) {\n        const size = stringLength(cell)\n        sizes[columnIndex] = size\n\n        if (\n          longestCellByColumn[columnIndex] === undefined ||\n          size > longestCellByColumn[columnIndex]\n        ) {\n          longestCellByColumn[columnIndex] = size\n        }\n      }\n\n      row.push(cell)\n    }\n\n    cellMatrix[rowIndex] = row\n    sizeMatrix[rowIndex] = sizes\n  }\n\n  // Figure out which alignments to use.\n  let columnIndex = -1\n\n  if (typeof align === 'object' && 'length' in align) {\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = toAlignment(align[columnIndex])\n    }\n  } else {\n    const code = toAlignment(align)\n\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = code\n    }\n  }\n\n  // Inject the alignment row.\n  columnIndex = -1\n  /** @type {Array<string>} */\n  const row = []\n  /** @type {Array<number>} */\n  const sizes = []\n\n  while (++columnIndex < mostCellsPerRow) {\n    const code = alignments[columnIndex]\n    let before = ''\n    let after = ''\n\n    if (code === 99 /* `c` */) {\n      before = ':'\n      after = ':'\n    } else if (code === 108 /* `l` */) {\n      before = ':'\n    } else if (code === 114 /* `r` */) {\n      after = ':'\n    }\n\n    // There *must* be at least one hyphen-minus in each alignment cell.\n    let size =\n      options.alignDelimiters === false\n        ? 1\n        : Math.max(\n            1,\n            longestCellByColumn[columnIndex] - before.length - after.length\n          )\n\n    const cell = before + '-'.repeat(size) + after\n\n    if (options.alignDelimiters !== false) {\n      size = before.length + size + after.length\n\n      if (size > longestCellByColumn[columnIndex]) {\n        longestCellByColumn[columnIndex] = size\n      }\n\n      sizes[columnIndex] = size\n    }\n\n    row[columnIndex] = cell\n  }\n\n  // Inject the alignment row.\n  cellMatrix.splice(1, 0, row)\n  sizeMatrix.splice(1, 0, sizes)\n\n  rowIndex = -1\n  /** @type {Array<string>} */\n  const lines = []\n\n  while (++rowIndex < cellMatrix.length) {\n    const row = cellMatrix[rowIndex]\n    const sizes = sizeMatrix[rowIndex]\n    columnIndex = -1\n    /** @type {Array<string>} */\n    const line = []\n\n    while (++columnIndex < mostCellsPerRow) {\n      const cell = row[columnIndex] || ''\n      let before = ''\n      let after = ''\n\n      if (options.alignDelimiters !== false) {\n        const size =\n          longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0)\n        const code = alignments[columnIndex]\n\n        if (code === 114 /* `r` */) {\n          before = ' '.repeat(size)\n        } else if (code === 99 /* `c` */) {\n          if (size % 2) {\n            before = ' '.repeat(size / 2 + 0.5)\n            after = ' '.repeat(size / 2 - 0.5)\n          } else {\n            before = ' '.repeat(size / 2)\n            after = before\n          }\n        } else {\n          after = ' '.repeat(size)\n        }\n      }\n\n      if (options.delimiterStart !== false && !columnIndex) {\n        line.push('|')\n      }\n\n      if (\n        options.padding !== false &&\n        // Dont add the opening space if were not aligning and the cell is\n        // empty: there will be a closing space.\n        !(options.alignDelimiters === false && cell === '') &&\n        (options.delimiterStart !== false || columnIndex)\n      ) {\n        line.push(' ')\n      }\n\n      if (options.alignDelimiters !== false) {\n        line.push(before)\n      }\n\n      line.push(cell)\n\n      if (options.alignDelimiters !== false) {\n        line.push(after)\n      }\n\n      if (options.padding !== false) {\n        line.push(' ')\n      }\n\n      if (\n        options.delimiterEnd !== false ||\n        columnIndex !== mostCellsPerRow - 1\n      ) {\n        line.push('|')\n      }\n    }\n\n    lines.push(\n      options.delimiterEnd === false\n        ? line.join('').replace(/ +$/, '')\n        : line.join('')\n    )\n  }\n\n  return lines.join('\\n')\n}\n\n/**\n * @param {string|null|undefined} [value]\n * @returns {string}\n */\nfunction serialize(value) {\n  return value === null || value === undefined ? '' : String(value)\n}\n\n/**\n * @param {string} value\n * @returns {number}\n */\nfunction defaultStringLength(value) {\n  return value.length\n}\n\n/**\n * @param {string|null|undefined} value\n * @returns {number}\n */\nfunction toAlignment(value) {\n  const code = typeof value === 'string' ? value.codePointAt(0) : 0\n\n  return code === 67 /* `C` */ || code === 99 /* `c` */\n    ? 99 /* `c` */\n    : code === 76 /* `L` */ || code === 108 /* `l` */\n    ? 108 /* `l` */\n    : code === 82 /* `R` */ || code === 114 /* `r` */\n    ? 114 /* `r` */\n    : 0\n}\n","/**\n * @typedef {import('mdast').AlignType} AlignType\n * @typedef {import('mdast').Table} Table\n * @typedef {import('mdast').TableRow} TableRow\n * @typedef {import('mdast').TableCell} TableCell\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('markdown-table').MarkdownTableOptions} MarkdownTableOptions\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Context} ToMarkdownContext\n * @typedef {import('mdast-util-to-markdown').SafeOptions} SafeOptions\n *\n * @typedef Options\n * @property {boolean} [tableCellPadding=true]\n * @property {boolean} [tablePipeAlign=true]\n * @property {MarkdownTableOptions['stringLength']} [stringLength]\n */\n\nimport {containerPhrasing} from 'mdast-util-to-markdown/lib/util/container-phrasing.js'\nimport {inlineCode} from 'mdast-util-to-markdown/lib/handle/inline-code.js'\nimport {markdownTable} from 'markdown-table'\n\n/** @type {FromMarkdownExtension} */\nexport const gfmTableFromMarkdown = {\n  enter: {\n    table: enterTable,\n    tableData: enterCell,\n    tableHeader: enterCell,\n    tableRow: enterRow\n  },\n  exit: {\n    codeText: exitCodeText,\n    table: exitTable,\n    tableData: exit,\n    tableHeader: exit,\n    tableRow: exit\n  }\n}\n\n/** @type {FromMarkdownHandle} */\nfunction enterTable(token) {\n  /** @type {Array<'left'|'right'|'center'|'none'>} */\n  // @ts-expect-error: `align` is custom.\n  const align = token._align\n  this.enter(\n    {\n      type: 'table',\n      align: align.map((d) => (d === 'none' ? null : d)),\n      children: []\n    },\n    token\n  )\n  this.setData('inTable', true)\n}\n\n/** @type {FromMarkdownHandle} */\nfunction exitTable(token) {\n  this.exit(token)\n  this.setData('inTable')\n}\n\n/** @type {FromMarkdownHandle} */\nfunction enterRow(token) {\n  this.enter({type: 'tableRow', children: []}, token)\n}\n\n/** @type {FromMarkdownHandle} */\nfunction exit(token) {\n  this.exit(token)\n}\n\n/** @type {FromMarkdownHandle} */\nfunction enterCell(token) {\n  this.enter({type: 'tableCell', children: []}, token)\n}\n\n// Overwrite the default code text data handler to unescape escaped pipes when\n// they are in tables.\n/** @type {FromMarkdownHandle} */\nfunction exitCodeText(token) {\n  let value = this.resume()\n\n  if (this.getData('inTable')) {\n    value = value.replace(/\\\\([\\\\|])/g, replace)\n  }\n\n  const node = /** @type {InlineCode} */ (this.stack[this.stack.length - 1])\n  node.value = value\n  this.exit(token)\n}\n\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */\nfunction replace($0, $1) {\n  // Pipes work, backslashes dont (but cant escape pipes).\n  return $1 === '|' ? $1 : $0\n}\n\n/**\n * @param {Options} [options]\n * @returns {ToMarkdownExtension}\n */\nexport function gfmTableToMarkdown(options) {\n  const settings = options || {}\n  const padding = settings.tableCellPadding\n  const alignDelimiters = settings.tablePipeAlign\n  const stringLength = settings.stringLength\n  const around = padding ? ' ' : '|'\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'tableCell'},\n      {character: '\\n', inConstruct: 'tableCell'},\n      // A pipe, when followed by a tab or space (padding), or a dash or colon\n      // (unpadded delimiter row), could result in a table.\n      {atBreak: true, character: '|', after: '[\\t :-]'},\n      // A pipe in a cell must be encoded.\n      {character: '|', inConstruct: 'tableCell'},\n      // A colon must be followed by a dash, in which case it could start a\n      // delimiter row.\n      {atBreak: true, character: ':', after: '-'},\n      // A delimiter row can also start with a dash, when followed by more\n      // dashes, a colon, or a pipe.\n      // This is a stricter version than the built in check for lists, thematic\n      // breaks, and setex heading underlines though:\n      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>\n      {atBreak: true, character: '-', after: '[:|-]'}\n    ],\n    handlers: {\n      table: handleTable,\n      tableRow: handleTableRow,\n      tableCell: handleTableCell,\n      inlineCode: inlineCodeWithTable\n    }\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Table} node\n   */\n  function handleTable(node, _, context, safeOptions) {\n    return serializeData(\n      handleTableAsData(node, context, safeOptions),\n      // @ts-expect-error: fixed in `markdown-table@3.0.1`.\n      node.align\n    )\n  }\n\n  /**\n   * This function isnt really used normally, because we handle rows at the\n   * table level.\n   * But, if someone passes in a table row, this ensures we make somewhat sense.\n   *\n   * @type {ToMarkdownHandle}\n   * @param {TableRow} node\n   */\n  function handleTableRow(node, _, context, safeOptions) {\n    const row = handleTableRowAsData(node, context, safeOptions)\n    // `markdown-table` will always add an align row\n    const value = serializeData([row])\n    return value.slice(0, value.indexOf('\\n'))\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {TableCell} node\n   */\n  function handleTableCell(node, _, context, safeOptions) {\n    const exit = context.enter('tableCell')\n    const subexit = context.enter('phrasing')\n    const value = containerPhrasing(node, context, {\n      ...safeOptions,\n      before: around,\n      after: around\n    })\n    subexit()\n    exit()\n    return value\n  }\n\n  /**\n   * @param {Array<Array<string>>} matrix\n   * @param {Array<string>} [align]\n   */\n  function serializeData(matrix, align) {\n    return markdownTable(matrix, {\n      align,\n      alignDelimiters,\n      padding,\n      stringLength\n    })\n  }\n\n  /**\n   * @param {Table} node\n   * @param {ToMarkdownContext} context\n   * @param {SafeOptions} safeOptions\n   */\n  function handleTableAsData(node, context, safeOptions) {\n    const children = node.children\n    let index = -1\n    /** @type {Array<Array<string>>} */\n    const result = []\n    const subexit = context.enter('table')\n\n    while (++index < children.length) {\n      result[index] = handleTableRowAsData(\n        children[index],\n        context,\n        safeOptions\n      )\n    }\n\n    subexit()\n\n    return result\n  }\n\n  /**\n   * @param {TableRow} node\n   * @param {ToMarkdownContext} context\n   * @param {SafeOptions} safeOptions\n   */\n  function handleTableRowAsData(node, context, safeOptions) {\n    const children = node.children\n    let index = -1\n    /** @type {Array<string>} */\n    const result = []\n    const subexit = context.enter('tableRow')\n\n    while (++index < children.length) {\n      // Note: the positional info as used here is incorrect.\n      // Making it correct would be impossible due to aligning cells?\n      // And it would need copy/pasting `markdown-table` into this project.\n      result[index] = handleTableCell(\n        children[index],\n        node,\n        context,\n        safeOptions\n      )\n    }\n\n    subexit()\n\n    return result\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineCode} node\n   */\n  function inlineCodeWithTable(node, parent, context) {\n    let value = inlineCode(node, parent, context)\n\n    if (context.stack.includes('tableCell')) {\n      value = value.replace(/\\|/g, '\\\\$&')\n    }\n\n    return value\n  }\n}\n","/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').List} List\n * @typedef {import('../util/indent-lines.js').Map} Map\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').Handle} Handle\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkListItemIndent} from '../util/check-list-item-indent.js'\nimport {containerFlow} from '../util/container-flow.js'\nimport {indentLines} from '../util/indent-lines.js'\nimport {track} from '../util/track.js'\n\n/**\n * @type {Handle}\n * @param {ListItem} node\n */\nexport function listItem(node, parent, context, safeOptions) {\n  const listItemIndent = checkListItemIndent(context)\n  let bullet = context.bulletCurrent || checkBullet(context)\n\n  // Add the marker value for ordered lists.\n  if (parent && parent.type === 'list' && parent.ordered) {\n    bullet =\n      (typeof parent.start === 'number' && parent.start > -1\n        ? parent.start\n        : 1) +\n      (context.options.incrementListMarker === false\n        ? 0\n        : parent.children.indexOf(node)) +\n      bullet\n  }\n\n  let size = bullet.length + 1\n\n  if (\n    listItemIndent === 'tab' ||\n    (listItemIndent === 'mixed' &&\n      ((parent && parent.type === 'list' && parent.spread) || node.spread))\n  ) {\n    size = Math.ceil(size / 4) * 4\n  }\n\n  const tracker = track(safeOptions)\n  tracker.move(bullet + ' '.repeat(size - bullet.length))\n  tracker.shift(size)\n  const exit = context.enter('listItem')\n  const value = indentLines(\n    containerFlow(node, context, tracker.current()),\n    map\n  )\n  exit()\n\n  return value\n\n  /** @type {Map} */\n  function map(line, index, blank) {\n    if (index) {\n      return (blank ? '' : ' '.repeat(size)) + line\n    }\n\n    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line\n  }\n}\n","/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {Context} context\n * @returns {Exclude<Options['listItemIndent'], undefined>}\n */\nexport function checkListItemIndent(context) {\n  const style = context.options.listItemIndent || 'tab'\n\n  // To do: remove in a major.\n  // @ts-expect-error: deprecated.\n  if (style === 1 || style === '1') {\n    return 'one'\n  }\n\n  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        style +\n        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'\n    )\n  }\n\n  return style\n}\n","/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {Context} context\n * @returns {Exclude<Options['bullet'], undefined>}\n */\nexport function checkBullet(context) {\n  const marker = context.options.bullet || '*'\n\n  if (marker !== '*' && marker !== '+' && marker !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bullet`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {Extract<import('mdast').Root|import('mdast').Content, import('unist').Parent>} Parent\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').BlockContent} BlockContent\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\nimport {listItem} from 'mdast-util-to-markdown/lib/handle/list-item.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\n/** @type {FromMarkdownExtension} */\nexport const gfmTaskListItemFromMarkdown = {\n  exit: {\n    taskListCheckValueChecked: exitCheck,\n    taskListCheckValueUnchecked: exitCheck,\n    paragraph: exitParagraphWithTaskListItem\n  }\n}\n\n/** @type {ToMarkdownExtension} */\nexport const gfmTaskListItemToMarkdown = {\n  unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],\n  handlers: {listItem: listItemWithTaskListItem}\n}\n\n/** @type {FromMarkdownHandle} */\nfunction exitCheck(token) {\n  const node = /** @type {ListItem} */ (this.stack[this.stack.length - 2])\n  // Were always in a paragraph, in a list item.\n  node.checked = token.type === 'taskListCheckValueChecked'\n}\n\n/** @type {FromMarkdownHandle} */\nfunction exitParagraphWithTaskListItem(token) {\n  const parent = /** @type {Parent} */ (this.stack[this.stack.length - 2])\n  const node = /** @type {Paragraph} */ (this.stack[this.stack.length - 1])\n  const siblings = parent.children\n  const head = node.children[0]\n  let index = -1\n  /** @type {Paragraph|undefined} */\n  let firstParaghraph\n\n  if (\n    parent &&\n    parent.type === 'listItem' &&\n    typeof parent.checked === 'boolean' &&\n    head &&\n    head.type === 'text'\n  ) {\n    while (++index < siblings.length) {\n      const sibling = siblings[index]\n      if (sibling.type === 'paragraph') {\n        firstParaghraph = sibling\n        break\n      }\n    }\n\n    if (firstParaghraph === node) {\n      // Must start with a space or a tab.\n      head.value = head.value.slice(1)\n\n      if (head.value.length === 0) {\n        node.children.shift()\n      } else if (\n        node.position &&\n        head.position &&\n        typeof head.position.start.offset === 'number'\n      ) {\n        head.position.start.column++\n        head.position.start.offset++\n        node.position.start = Object.assign({}, head.position.start)\n      }\n    }\n  }\n\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {ListItem} node\n */\nfunction listItemWithTaskListItem(node, parent, context, safeOptions) {\n  const head = node.children[0]\n  const checkable =\n    typeof node.checked === 'boolean' && head && head.type === 'paragraph'\n  const checkbox = '[' + (node.checked ? 'x' : ' ') + '] '\n  const tracker = track(safeOptions)\n\n  if (checkable) {\n    tracker.move(checkbox)\n  }\n\n  let value = listItem(node, parent, context, {\n    ...safeOptions,\n    ...tracker.current()\n  })\n\n  if (checkable) {\n    value = value.replace(/^(?:[*+-]|\\d+\\.)([\\r\\n]| {1,3})/, check)\n  }\n\n  return value\n\n  /**\n   * @param {string} $0\n   * @returns {string}\n   */\n  function check($0) {\n    return $0 + checkbox\n  }\n}\n","/**\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n *\n * @typedef {import('mdast-util-gfm-table').Options} Options\n */\n\nimport {\n  gfmAutolinkLiteralFromMarkdown,\n  gfmAutolinkLiteralToMarkdown\n} from 'mdast-util-gfm-autolink-literal'\nimport {\n  gfmFootnoteFromMarkdown,\n  gfmFootnoteToMarkdown\n} from 'mdast-util-gfm-footnote'\nimport {\n  gfmStrikethroughFromMarkdown,\n  gfmStrikethroughToMarkdown\n} from 'mdast-util-gfm-strikethrough'\nimport {gfmTableFromMarkdown, gfmTableToMarkdown} from 'mdast-util-gfm-table'\nimport {\n  gfmTaskListItemFromMarkdown,\n  gfmTaskListItemToMarkdown\n} from 'mdast-util-gfm-task-list-item'\n\n/**\n * @returns {Array<FromMarkdownExtension>}\n */\nexport function gfmFromMarkdown() {\n  return [\n    gfmAutolinkLiteralFromMarkdown,\n    gfmFootnoteFromMarkdown(),\n    gfmStrikethroughFromMarkdown,\n    gfmTableFromMarkdown,\n    gfmTaskListItemFromMarkdown\n  ]\n}\n\n/**\n * @param {Options} [options]\n * @returns {ToMarkdownExtension}\n */\nexport function gfmToMarkdown(options) {\n  return {\n    extensions: [\n      gfmAutolinkLiteralToMarkdown,\n      gfmFootnoteToMarkdown(),\n      gfmStrikethroughToMarkdown,\n      gfmTableToMarkdown(options),\n      gfmTaskListItemToMarkdown\n    ]\n  }\n}\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('micromark-extension-gfm').Options & import('mdast-util-gfm').Options} Options\n */\n\nimport {gfm} from 'micromark-extension-gfm'\nimport {gfmFromMarkdown, gfmToMarkdown} from 'mdast-util-gfm'\n\n/**\n * Plugin to support GFM (autolink literals, footnotes, strikethrough, tables, tasklists).\n *\n * @type {import('unified').Plugin<[Options?]|void[], Root>}\n */\nexport default function remarkGfm(options = {}) {\n  const data = this.data()\n\n  add('micromarkExtensions', gfm(options))\n  add('fromMarkdownExtensions', gfmFromMarkdown())\n  add('toMarkdownExtensions', gfmToMarkdown(options))\n\n  /**\n   * @param {string} field\n   * @param {unknown} value\n   */\n  function add(field, value) {\n    const list = /** @type {unknown[]} */ (\n      // Other extensions\n      /* c8 ignore next 2 */\n      data[field] ? data[field] : (data[field] = [])\n    )\n\n    list.push(value)\n  }\n}\n","var own = {}.hasOwnProperty\n\n/**\n * Check if `node` has a set `name` property.\n *\n * @param {unknown} node\n * @param {string} name\n * @returns {boolean}\n */\nexport function hasProperty(node, name) {\n  /** @type {unknown} */\n  var value =\n    name &&\n    node &&\n    typeof node === 'object' &&\n    // @ts-ignore Looks like a node.\n    node.type === 'element' &&\n    // @ts-ignore Looks like an element.\n    node.properties &&\n    // @ts-ignore Looks like an element.\n    own.call(node.properties, name) &&\n    // @ts-ignore Looks like an element.\n    node.properties[name]\n\n  return value !== null && value !== undefined && value !== false\n}\n","/**\n * @fileoverview\n *   Get the plain-text value of a hast node.\n * @longdescription\n *   ## Use\n *\n *   ```js\n *   import {h} from 'hastscript'\n *   import {toString} from 'hast-util-to-string'\n *\n *   toString(h('p', 'Alpha'))\n *   //=> 'Alpha'\n *   toString(h('div', [h('b', 'Bold'), ' and ', h('i', 'italic'), '.']))\n *   //=> 'Bold and italic.'\n *   ```\n *\n *   ## API\n *\n *   ### `toString(node)`\n *\n *   Transform a node to a string.\n */\n\n/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Element} Element\n * @typedef {Root|Root['children'][number]} Node\n */\n\n/**\n * Get the plain-text value of a hast node.\n *\n * @param {Node} node\n * @returns {string}\n */\nexport function toString(node) {\n  // The concatenation of data of all the Text node descendants of the context\n  // object, in tree order.\n  if ('children' in node) {\n    return all(node)\n  }\n\n  // Context objects data.\n  return 'value' in node ? node.value : ''\n}\n\n/**\n * @param {Node} node\n * @returns {string}\n */\nfunction one(node) {\n  if (node.type === 'text') {\n    return node.value\n  }\n\n  return 'children' in node ? all(node) : ''\n}\n\n/**\n * @param {Root|Element} node\n * @returns {string}\n */\nfunction all(node) {\n  let index = -1\n  /** @type {string[]} */\n  const result = []\n\n  while (++index < node.children.length) {\n    result[index] = one(node.children[index])\n  }\n\n  return result.join('')\n}\n","/**\n * @typedef {import('hast').Root} Root\n */\n\nimport Slugger from 'github-slugger'\nimport {hasProperty} from 'hast-util-has-property'\nimport {headingRank} from 'hast-util-heading-rank'\nimport {toString} from 'hast-util-to-string'\nimport {visit} from 'unist-util-visit'\n\nconst slugs = new Slugger()\n\n/**\n * Plugin to add `id`s to headings.\n *\n * @type {import('unified').Plugin<Array<void>, Root>}\n */\nexport default function rehypeSlug() {\n  return (tree) => {\n    slugs.reset()\n\n    visit(tree, 'element', (node) => {\n      if (headingRank(node) && node.properties && !hasProperty(node, 'id')) {\n        node.properties.id = slugs.slug(toString(node))\n      }\n    })\n  }\n}\n","/**\n * @typedef {import('hast').Parent} Parent\n * @typedef {import('hast').Root} Root\n * @typedef {Root|Parent['children'][number]} Node\n */\n\n/**\n * Rank of a heading: H1 -> 1, H2 -> 2, etc.\n *\n * @param {Node} node\n * @returns {number|null}\n */\nexport function headingRank(node) {\n  var name =\n    (node && node.type === 'element' && node.tagName.toLowerCase()) || ''\n  var code =\n    name.length === 2 && name.charCodeAt(0) === 104 /* `h` */\n      ? name.charCodeAt(1)\n      : 0\n  return code > 48 /* `0` */ && code < 55 /* `7` */ ? code - 48 /* `0` */ : null\n}\n"],"sourceRoot":""}